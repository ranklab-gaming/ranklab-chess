/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/styles.scss":
/*!*************************!*\
  !*** ./src/styles.scss ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://ranklab-chess/./src/styles.scss?");

/***/ }),

/***/ "./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/h.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/h.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addNS\": () => (/* binding */ addNS),\n/* harmony export */   \"fragment\": () => (/* binding */ fragment),\n/* harmony export */   \"h\": () => (/* binding */ h)\n/* harmony export */ });\n/* harmony import */ var _vnode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vnode */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/vnode.js\");\n/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/is.js\");\n\n\nfunction addNS(data, children, sel) {\n    data.ns = \"http://www.w3.org/2000/svg\";\n    if (sel !== \"foreignObject\" && children !== undefined) {\n        for (let i = 0; i < children.length; ++i) {\n            const child = children[i];\n            if (typeof child === \"string\")\n                continue;\n            const childData = child.data;\n            if (childData !== undefined) {\n                addNS(childData, child.children, child.sel);\n            }\n        }\n    }\n}\nfunction h(sel, b, c) {\n    let data = {};\n    let children;\n    let text;\n    let i;\n    if (c !== undefined) {\n        if (b !== null) {\n            data = b;\n        }\n        if (_is__WEBPACK_IMPORTED_MODULE_0__.array(c)) {\n            children = c;\n        }\n        else if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(c)) {\n            text = c.toString();\n        }\n        else if (c && c.sel) {\n            children = [c];\n        }\n    }\n    else if (b !== undefined && b !== null) {\n        if (_is__WEBPACK_IMPORTED_MODULE_0__.array(b)) {\n            children = b;\n        }\n        else if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(b)) {\n            text = b.toString();\n        }\n        else if (b && b.sel) {\n            children = [b];\n        }\n        else {\n            data = b;\n        }\n    }\n    if (children !== undefined) {\n        for (i = 0; i < children.length; ++i) {\n            if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(children[i]))\n                children[i] = (0,_vnode__WEBPACK_IMPORTED_MODULE_1__.vnode)(undefined, undefined, undefined, children[i], undefined);\n        }\n    }\n    if (sel[0] === \"s\" &&\n        sel[1] === \"v\" &&\n        sel[2] === \"g\" &&\n        (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) {\n        addNS(data, children, sel);\n    }\n    return (0,_vnode__WEBPACK_IMPORTED_MODULE_1__.vnode)(sel, data, children, text, undefined);\n}\n/**\n * @experimental\n */\nfunction fragment(children) {\n    let c;\n    let text;\n    if (_is__WEBPACK_IMPORTED_MODULE_0__.array(children)) {\n        c = children;\n    }\n    else if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(c)) {\n        text = children;\n    }\n    else if (c && c.sel) {\n        c = [children];\n    }\n    if (c !== undefined) {\n        for (let i = 0; i < c.length; ++i) {\n            if (_is__WEBPACK_IMPORTED_MODULE_0__.primitive(c[i]))\n                c[i] = (0,_vnode__WEBPACK_IMPORTED_MODULE_1__.vnode)(undefined, undefined, undefined, c[i], undefined);\n        }\n    }\n    return (0,_vnode__WEBPACK_IMPORTED_MODULE_1__.vnode)(undefined, {}, c, text, undefined);\n}\n//# sourceMappingURL=h.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/h.js?");

/***/ }),

/***/ "./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/htmldomapi.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/htmldomapi.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"htmlDomApi\": () => (/* binding */ htmlDomApi)\n/* harmony export */ });\nfunction createElement(tagName, options) {\n    return document.createElement(tagName, options);\n}\nfunction createElementNS(namespaceURI, qualifiedName, options) {\n    return document.createElementNS(namespaceURI, qualifiedName, options);\n}\nfunction createDocumentFragment() {\n    return parseFragment(document.createDocumentFragment());\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    if (isDocumentFragment(parentNode)) {\n        let node = parentNode;\n        while (node && isDocumentFragment(node)) {\n            const fragment = parseFragment(node);\n            node = fragment.parent;\n        }\n        parentNode = node !== null && node !== void 0 ? node : parentNode;\n    }\n    if (isDocumentFragment(newNode)) {\n        newNode = parseFragment(newNode, parentNode);\n    }\n    if (referenceNode && isDocumentFragment(referenceNode)) {\n        referenceNode = parseFragment(referenceNode).firstChildNode;\n    }\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    if (isDocumentFragment(child)) {\n        child = parseFragment(child, node);\n    }\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    if (isDocumentFragment(node)) {\n        while (node && isDocumentFragment(node)) {\n            const fragment = parseFragment(node);\n            node = fragment.parent;\n        }\n        return node !== null && node !== void 0 ? node : null;\n    }\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    var _a;\n    if (isDocumentFragment(node)) {\n        const fragment = parseFragment(node);\n        const parent = parentNode(fragment);\n        if (parent && fragment.lastChildNode) {\n            const children = Array.from(parent.childNodes);\n            const index = children.indexOf(fragment.lastChildNode);\n            return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;\n        }\n        return null;\n    }\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nfunction isDocumentFragment(node) {\n    return node.nodeType === 11;\n}\nfunction parseFragment(fragmentNode, parentNode) {\n    var _a, _b, _c;\n    const fragment = fragmentNode;\n    (_a = fragment.parent) !== null && _a !== void 0 ? _a : (fragment.parent = parentNode !== null && parentNode !== void 0 ? parentNode : null);\n    (_b = fragment.firstChildNode) !== null && _b !== void 0 ? _b : (fragment.firstChildNode = fragmentNode.firstChild);\n    (_c = fragment.lastChildNode) !== null && _c !== void 0 ? _c : (fragment.lastChildNode = fragmentNode.lastChild);\n    return fragment;\n}\nconst htmlDomApi = {\n    createElement,\n    createElementNS,\n    createTextNode,\n    createDocumentFragment,\n    createComment,\n    insertBefore,\n    removeChild,\n    appendChild,\n    parentNode,\n    nextSibling,\n    tagName,\n    setTextContent,\n    getTextContent,\n    isElement,\n    isText,\n    isComment,\n    isDocumentFragment,\n};\n//# sourceMappingURL=htmldomapi.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/htmldomapi.js?");

/***/ }),

/***/ "./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/init.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/init.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"init\": () => (/* binding */ init)\n/* harmony export */ });\n/* harmony import */ var _vnode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vnode */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/vnode.js\");\n/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/is.js\");\n/* harmony import */ var _htmldomapi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./htmldomapi */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/htmldomapi.js\");\n\n\n\nfunction isUndef(s) {\n    return s === undefined;\n}\nfunction isDef(s) {\n    return s !== undefined;\n}\nconst emptyNode = (0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(\"\", {}, [], undefined, undefined);\nfunction sameVnode(vnode1, vnode2) {\n    var _a, _b;\n    const isSameKey = vnode1.key === vnode2.key;\n    const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);\n    const isSameSel = vnode1.sel === vnode2.sel;\n    const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel\n        ? typeof vnode1.text === typeof vnode2.text\n        : true;\n    return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;\n}\n/**\n * @todo Remove this function when the document fragment is considered stable.\n */\nfunction documentFragmentIsNotSupported() {\n    throw new Error(\"The document fragment is not supported on this platform.\");\n}\nfunction isElement(api, vnode) {\n    return api.isElement(vnode);\n}\nfunction isDocumentFragment(api, vnode) {\n    return api.isDocumentFragment(vnode);\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var _a;\n    const map = {};\n    for (let i = beginIdx; i <= endIdx; ++i) {\n        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;\n        if (key !== undefined) {\n            map[key] = i;\n        }\n    }\n    return map;\n}\nconst hooks = [\n    \"create\",\n    \"update\",\n    \"remove\",\n    \"destroy\",\n    \"pre\",\n    \"post\",\n];\nfunction init(modules, domApi, options) {\n    const cbs = {\n        create: [],\n        update: [],\n        remove: [],\n        destroy: [],\n        pre: [],\n        post: [],\n    };\n    const api = domApi !== undefined ? domApi : _htmldomapi__WEBPACK_IMPORTED_MODULE_1__.htmlDomApi;\n    for (const hook of hooks) {\n        for (const module of modules) {\n            const currentHook = module[hook];\n            if (currentHook !== undefined) {\n                cbs[hook].push(currentHook);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        const id = elm.id ? \"#\" + elm.id : \"\";\n        // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n        // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n        const classes = elm.getAttribute(\"class\");\n        const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function emptyDocumentFragmentAt(frag) {\n        return (0,_vnode__WEBPACK_IMPORTED_MODULE_0__.vnode)(undefined, {}, [], undefined, frag);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                const parent = api.parentNode(childElm);\n                api.removeChild(parent, childElm);\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d;\n        let i;\n        let data = vnode.data;\n        if (data !== undefined) {\n            const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;\n            if (isDef(init)) {\n                init(vnode);\n                data = vnode.data;\n            }\n        }\n        const children = vnode.children;\n        const sel = vnode.sel;\n        if (sel === \"!\") {\n            if (isUndef(vnode.text)) {\n                vnode.text = \"\";\n            }\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            const hashIdx = sel.indexOf(\"#\");\n            const dotIdx = sel.indexOf(\".\", hashIdx);\n            const hash = hashIdx > 0 ? hashIdx : sel.length;\n            const dot = dotIdx > 0 ? dotIdx : sel.length;\n            const tag = hashIdx !== -1 || dotIdx !== -1\n                ? sel.slice(0, Math.min(hash, dot))\n                : sel;\n            const elm = (vnode.elm =\n                isDef(data) && isDef((i = data.ns))\n                    ? api.createElementNS(i, tag, data)\n                    : api.createElement(tag, data));\n            if (hash < dot)\n                elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n            if (dotIdx > 0)\n                elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            if (_is__WEBPACK_IMPORTED_MODULE_2__.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    const ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            else if (_is__WEBPACK_IMPORTED_MODULE_2__.primitive(vnode.text)) {\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            const hook = vnode.data.hook;\n            if (isDef(hook)) {\n                (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode);\n                if (hook.insert) {\n                    insertedVnodeQueue.push(vnode);\n                }\n            }\n        }\n        else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode.children) {\n            vnode.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            for (i = 0; i < vnode.children.length; ++i) {\n                const ch = vnode.children[i];\n                if (ch != null) {\n                    api.appendChild(vnode.elm, createElm(ch, insertedVnodeQueue));\n                }\n            }\n        }\n        else {\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var _a, _b;\n        const data = vnode.data;\n        if (data !== undefined) {\n            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode);\n            for (let i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) {\n                for (let j = 0; j < vnode.children.length; ++j) {\n                    const child = vnode.children[j];\n                    if (child != null && typeof child !== \"string\") {\n                        invokeDestroyHook(child);\n                    }\n                }\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        var _a, _b;\n        for (; startIdx <= endIdx; ++startIdx) {\n            let listeners;\n            let rm;\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                if (isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for (let i = 0; i < cbs.remove.length; ++i)\n                        cbs.remove[i](ch, rm);\n                    const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;\n                    if (isDef(removeHook)) {\n                        removeHook(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else if (ch.children) {\n                    // Fragment node\n                    invokeDestroyHook(ch);\n                    removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);\n                }\n                else {\n                    // Text node\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        let oldStartIdx = 0;\n        let newStartIdx = 0;\n        let oldEndIdx = oldCh.length - 1;\n        let oldStartVnode = oldCh[0];\n        let oldEndVnode = oldCh[oldEndIdx];\n        let newEndIdx = newCh.length - 1;\n        let newStartVnode = newCh[0];\n        let newEndVnode = newCh[newEndIdx];\n        let oldKeyToIdx;\n        let idxInOld;\n        let elmToMove;\n        let before;\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\n                // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\n                // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) {\n                    // New element\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                }\n                else {\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n        if (newStartIdx <= newEndIdx) {\n            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        }\n        if (oldStartIdx <= oldEndIdx) {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;\n        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode);\n        const elm = (vnode.elm = oldVnode.elm);\n        if (oldVnode === vnode)\n            return;\n        if (vnode.data !== undefined ||\n            (isDef(vnode.text) && vnode.text !== oldVnode.text)) {\n            (_c = vnode.data) !== null && _c !== void 0 ? _c : (vnode.data = {});\n            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : (oldVnode.data = {});\n            for (let i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            (_g = (_f = (_e = vnode.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode);\n        }\n        const oldCh = oldVnode.children;\n        const ch = vnode.children;\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, \"\");\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, \"\");\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            api.setTextContent(elm, vnode.text);\n        }\n        (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode);\n    }\n    return function patch(oldVnode, vnode) {\n        let i, elm, parent;\n        const insertedVnodeQueue = [];\n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (isElement(api, oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        else if (isDocumentFragment(api, oldVnode)) {\n            oldVnode = emptyDocumentFragmentAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\n//# sourceMappingURL=init.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/init.js?");

/***/ }),

/***/ "./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/is.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/is.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"array\": () => (/* binding */ array),\n/* harmony export */   \"primitive\": () => (/* binding */ primitive)\n/* harmony export */ });\nconst array = Array.isArray;\nfunction primitive(s) {\n    return (typeof s === \"string\" ||\n        typeof s === \"number\" ||\n        s instanceof String ||\n        s instanceof Number);\n}\n//# sourceMappingURL=is.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/is.js?");

/***/ }),

/***/ "./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/modules/attributes.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/modules/attributes.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"attributesModule\": () => (/* binding */ attributesModule)\n/* harmony export */ });\nconst xlinkNS = \"http://www.w3.org/1999/xlink\";\nconst xmlNS = \"http://www.w3.org/XML/1998/namespace\";\nconst colonChar = 58;\nconst xChar = 120;\nfunction updateAttrs(oldVnode, vnode) {\n    let key;\n    const elm = vnode.elm;\n    let oldAttrs = oldVnode.data.attrs;\n    let attrs = vnode.data.attrs;\n    if (!oldAttrs && !attrs)\n        return;\n    if (oldAttrs === attrs)\n        return;\n    oldAttrs = oldAttrs || {};\n    attrs = attrs || {};\n    // update modified attributes, add new attributes\n    for (key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            if (cur === true) {\n                elm.setAttribute(key, \"\");\n            }\n            else if (cur === false) {\n                elm.removeAttribute(key);\n            }\n            else {\n                if (key.charCodeAt(0) !== xChar) {\n                    elm.setAttribute(key, cur);\n                }\n                else if (key.charCodeAt(3) === colonChar) {\n                    // Assume xml namespace\n                    elm.setAttributeNS(xmlNS, key, cur);\n                }\n                else if (key.charCodeAt(5) === colonChar) {\n                    // Assume xlink namespace\n                    elm.setAttributeNS(xlinkNS, key, cur);\n                }\n                else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n    }\n    // remove removed attributes\n    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n    // the other option is to remove all attributes with value == undefined\n    for (key in oldAttrs) {\n        if (!(key in attrs)) {\n            elm.removeAttribute(key);\n        }\n    }\n}\nconst attributesModule = {\n    create: updateAttrs,\n    update: updateAttrs,\n};\n//# sourceMappingURL=attributes.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/modules/attributes.js?");

/***/ }),

/***/ "./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/modules/class.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/modules/class.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"classModule\": () => (/* binding */ classModule)\n/* harmony export */ });\nfunction updateClass(oldVnode, vnode) {\n    let cur;\n    let name;\n    const elm = vnode.elm;\n    let oldClass = oldVnode.data.class;\n    let klass = vnode.data.class;\n    if (!oldClass && !klass)\n        return;\n    if (oldClass === klass)\n        return;\n    oldClass = oldClass || {};\n    klass = klass || {};\n    for (name in oldClass) {\n        if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) {\n            // was `true` and now not provided\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        cur = klass[name];\n        if (cur !== oldClass[name]) {\n            elm.classList[cur ? \"add\" : \"remove\"](name);\n        }\n    }\n}\nconst classModule = { create: updateClass, update: updateClass };\n//# sourceMappingURL=class.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/modules/class.js?");

/***/ }),

/***/ "./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/vnode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/vnode.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"vnode\": () => (/* binding */ vnode)\n/* harmony export */ });\nfunction vnode(sel, data, children, text, elm) {\n    const key = data === undefined ? undefined : data.key;\n    return { sel, data, children, text, elm, key };\n}\n//# sourceMappingURL=vnode.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/vnode.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__webpack_require__(/*! ./styles.scss */ \"./src/styles.scss\");\nvar lichess_pgn_viewer_1 = __importDefault(__webpack_require__(/*! @ranklab-gaming/lichess-pgn-viewer */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/main.js\"));\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    (0, lichess_pgn_viewer_1.default)(document.getElementById(\"b1\"), {\n        pgn: \"e4 c5 Nf3 d6 e5 Nc6 exd6 Qxd6 Nc3 Nf6\",\n    });\n});\n\n\n//# sourceURL=webpack://ranklab-chess/./src/index.ts?");

/***/ }),

/***/ "./node_modules/.pnpm/@badrap+result@0.2.13/node_modules/@badrap/result/dist/index.modern.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@badrap+result@0.2.13/node_modules/@badrap/result/dist/index.modern.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Result\": () => (/* binding */ n)\n/* harmony export */ });\nclass r{unwrap(r,t){const e=this._chain(t=>n.ok(r?r(t):t),r=>t?n.ok(t(r)):n.err(r));if(e.isErr)throw e.error;return e.value}map(r,t){return this._chain(t=>n.ok(r(t)),r=>n.err(t?t(r):r))}chain(r,t){return this._chain(r,t||(r=>n.err(r)))}}class t extends r{constructor(r){super(),this.value=void 0,this.isOk=!0,this.isErr=!1,this.value=r}_chain(r,t){return r(this.value)}}class e extends r{constructor(r){super(),this.error=void 0,this.isOk=!1,this.isErr=!0,this.error=r}_chain(r,t){return t(this.error)}}var n;!function(r){r.ok=function(r){return new t(r)},r.err=function(r){return new e(r||new Error)},r.all=function(t){if(Array.isArray(t)){const e=[];for(let r=0;r<t.length;r++){const n=t[r];if(n.isErr)return n;e.push(n.value)}return r.ok(e)}const e={},n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];if(s.isErr)return s;e[n[r]]=s.value}return r.ok(e)}}(n||(n={}));\n//# sourceMappingURL=index.modern.mjs.map\n\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@badrap+result@0.2.13/node_modules/@badrap/result/dist/index.modern.mjs?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/config.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/config.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst defaults = {\n    pgn: '*',\n    fen: undefined,\n    showPlayers: 'auto',\n    showClocks: true,\n    showMoves: 'auto',\n    showControls: true,\n    scrollToMove: true,\n    orientation: 'white',\n    initialPly: 0,\n    chessground: {},\n    drawArrows: true,\n    menu: {\n        getPgn: {\n            enabled: true,\n            fileName: undefined, // name of the file when user clicks \"Download PGN\". Leave empty for automatic name.\n        },\n    },\n    lichess: 'https://lichess.org',\n    classes: undefined, // CSS classes to set on the root element. Defaults to the element classes before being replaced by LPV.\n};\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(element, cfg) {\n    const opts = { ...defaults };\n    deepMerge(opts, cfg);\n    if (opts.fen)\n        opts.pgn = `[FEN \"${opts.fen}\"]\\n${opts.pgn}`;\n    if (!opts.classes)\n        opts.classes = element.className;\n    return opts;\n}\nfunction deepMerge(base, extend) {\n    for (const key in extend) {\n        if (typeof extend[key] !== 'undefined') {\n            if (isPlainObject(base[key]) && isPlainObject(extend[key]))\n                deepMerge(base[key], extend[key]);\n            else\n                base[key] = extend[key];\n        }\n    }\n}\nfunction isPlainObject(o) {\n    if (typeof o !== 'object' || o === null)\n        return false;\n    const proto = Object.getPrototypeOf(o);\n    return proto === Object.prototype || proto === null;\n}\n//# sourceMappingURL=config.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/config.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/ctrl.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/ctrl.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Ctrl)\n/* harmony export */ });\n/* harmony import */ var chessops__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! chessops */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n/* harmony import */ var _translation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./translation */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/translation.js\");\n/* harmony import */ var chessground_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chessground/util */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/path.js\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./game */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/game.js\");\n/* harmony import */ var _pgn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pgn */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/pgn.js\");\n\n\n\n\n\n\nclass Ctrl {\n    constructor(opts, redraw) {\n        this.opts = opts;\n        this.redraw = redraw;\n        this.flipped = false;\n        this.pane = 'board';\n        this.autoScrollRequested = false;\n        this.curNode = () => this.game.nodeAt(this.path) || this.game.moves;\n        this.curData = () => this.game.dataAt(this.path) || this.game.initial;\n        this.goTo = (to, focus = true) => {\n            var _a, _b;\n            const path = to == 'first'\n                ? _path__WEBPACK_IMPORTED_MODULE_2__.Path.root\n                : to == 'prev'\n                    ? this.path.init()\n                    : to == 'next'\n                        ? (_b = (_a = this.game.nodeAt(this.path)) === null || _a === void 0 ? void 0 : _a.children[0]) === null || _b === void 0 ? void 0 : _b.data.path\n                        : this.game.pathAtMainlinePly('last');\n            this.toPath(path || this.path, focus);\n        };\n        this.canGoTo = (to) => (to == 'prev' || to == 'first' ? !this.path.empty() : !!this.curNode().children[0]);\n        this.toPath = (path, focus = true) => {\n            this.path = path;\n            this.pane = 'board';\n            this.autoScrollRequested = true;\n            this.redrawGround();\n            this.redraw();\n            if (focus)\n                this.focus();\n        };\n        this.focus = () => { var _a; return (_a = this.div) === null || _a === void 0 ? void 0 : _a.focus(); };\n        this.toggleMenu = () => {\n            this.pane = this.pane == 'board' ? 'menu' : 'board';\n            this.redraw();\n        };\n        this.togglePgn = () => {\n            this.pane = this.pane == 'pgn' ? 'board' : 'pgn';\n            this.redraw();\n        };\n        this.orientation = () => {\n            const base = this.opts.orientation || 'white';\n            return this.flipped ? (0,chessops__WEBPACK_IMPORTED_MODULE_5__.opposite)(base) : base;\n        };\n        this.flip = () => {\n            this.flipped = !this.flipped;\n            this.pane = 'board';\n            this.redrawGround();\n            this.redraw();\n        };\n        this.cgState = () => {\n            var _a;\n            const data = this.curData();\n            const lastMove = (0,_game__WEBPACK_IMPORTED_MODULE_3__.isMoveData)(data) ? (0,chessground_util__WEBPACK_IMPORTED_MODULE_1__.uciToMove)(data.uci) : (_a = this.opts.chessground) === null || _a === void 0 ? void 0 : _a.lastMove;\n            return {\n                fen: this.curData().fen,\n                orientation: this.orientation(),\n                check: this.curData().check,\n                lastMove,\n                turnColor: data.turn,\n            };\n        };\n        this.analysisUrl = () => (this.game.metadata.isLichess && this.game.metadata.externalLink) ||\n            `https://lichess.org/analysis/${this.curData().fen.replace(' ', '_')}?color=${this.orientation()}`;\n        this.practiceUrl = () => `${this.analysisUrl()}#practice`;\n        this.setGround = (cg) => {\n            this.ground = cg;\n            this.redrawGround();\n        };\n        this.redrawGround = () => this.withGround(g => {\n            g.set(this.cgState());\n            g.setShapes(this.curData().shapes.map(s => ({\n                orig: (0,chessops__WEBPACK_IMPORTED_MODULE_5__.makeSquare)(s.from),\n                dest: (0,chessops__WEBPACK_IMPORTED_MODULE_5__.makeSquare)(s.to),\n                brush: s.color,\n            })));\n        });\n        this.withGround = (f) => this.ground && f(this.ground);\n        this.game = (0,_pgn__WEBPACK_IMPORTED_MODULE_4__.makeGame)(opts.pgn, opts.lichess);\n        this.translate = (0,_translation__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(opts.translate);\n        this.path = this.game.pathAtMainlinePly(opts.initialPly);\n    }\n}\n//# sourceMappingURL=ctrl.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/ctrl.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/events.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/events.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"eventRepeater\": () => (/* binding */ eventRepeater),\n/* harmony export */   \"onKeyDown\": () => (/* binding */ onKeyDown),\n/* harmony export */   \"stepwiseScroll\": () => (/* binding */ stepwiseScroll)\n/* harmony export */ });\nfunction stepwiseScroll(inner) {\n    let scrollTotal = 0;\n    return (e) => {\n        scrollTotal += e.deltaY * (e.deltaMode ? 40 : 1);\n        if (Math.abs(scrollTotal) >= 4) {\n            inner(e, true);\n            scrollTotal = 0;\n        }\n        else {\n            inner(e, false);\n        }\n    };\n}\nfunction eventRepeater(action, e) {\n    const repeat = () => {\n        action();\n        delay = Math.max(100, delay - delay / 15);\n        timeout = setTimeout(repeat, delay);\n    };\n    let delay = 350;\n    let timeout = setTimeout(repeat, 500);\n    action();\n    const eventName = e.type == 'touchstart' ? 'touchend' : 'mouseup';\n    document.addEventListener(eventName, () => clearTimeout(timeout), { once: true });\n}\nconst suppressKeyNavOn = (e) => e.altKey ||\n    e.ctrlKey ||\n    e.shiftKey ||\n    e.metaKey ||\n    document.activeElement instanceof HTMLInputElement ||\n    document.activeElement instanceof HTMLTextAreaElement;\nconst onKeyDown = (ctrl) => (e) => {\n    if (suppressKeyNavOn(e))\n        return;\n    else if (e.key == 'ArrowLeft')\n        ctrl.goTo('prev');\n    else if (e.key == 'ArrowRight')\n        ctrl.goTo('next');\n    else if (e.key == 'f')\n        ctrl.flip();\n};\n//# sourceMappingURL=events.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/events.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/game.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/game.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => (/* binding */ Game),\n/* harmony export */   \"isMoveData\": () => (/* binding */ isMoveData),\n/* harmony export */   \"isMoveNode\": () => (/* binding */ isMoveNode)\n/* harmony export */ });\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/path.js\");\n\n// immutable\nclass Game {\n    constructor(initial, moves, players, metadata) {\n        this.initial = initial;\n        this.moves = moves;\n        this.players = players;\n        this.metadata = metadata;\n        this.nodeAt = (path) => nodeAtPathFrom(this.moves, path);\n        this.dataAt = (path) => {\n            const node = this.nodeAt(path);\n            return node ? (isMoveNode(node) ? node.data : this.initial) : undefined;\n        };\n        this.title = () => this.players.white.name\n            ? [this.players.white.title, this.players.white.name, 'vs', this.players.black.title, this.players.black.name]\n                .filter(x => x && !!x.trim())\n                .join('_')\n                .replace(' ', '-')\n            : 'lichess-pgn-viewer';\n        this.pathAtMainlinePly = (ply) => {\n            var _a;\n            return ply == 0\n                ? _path__WEBPACK_IMPORTED_MODULE_0__.Path.root\n                : ((_a = this.mainline[Math.max(0, Math.min(this.mainline.length - 1, ply == 'last' ? 9999 : ply - 1))]) === null || _a === void 0 ? void 0 : _a.path) ||\n                    _path__WEBPACK_IMPORTED_MODULE_0__.Path.root;\n        };\n        this.hasPlayerName = () => { var _a, _b; return !!(((_a = this.players.white) === null || _a === void 0 ? void 0 : _a.name) || ((_b = this.players.black) === null || _b === void 0 ? void 0 : _b.name)); };\n        this.mainline = Array.from(this.moves.mainline());\n    }\n}\nconst childById = (node, id) => node.children.find(c => c.data.path.last() == id);\nconst nodeAtPathFrom = (node, path) => {\n    if (path.empty())\n        return node;\n    const child = childById(node, path.head());\n    return child ? nodeAtPathFrom(child, path.tail()) : undefined;\n};\nconst isMoveNode = (n) => 'data' in n;\nconst isMoveData = (d) => 'uci' in d;\n//# sourceMappingURL=game.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/game.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/main.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/main.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ start)\n/* harmony export */ });\n/* harmony import */ var _ctrl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ctrl */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/ctrl.js\");\n/* harmony import */ var _view_main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view/main */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/main.js\");\n/* harmony import */ var snabbdom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! snabbdom */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/init.js\");\n/* harmony import */ var snabbdom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! snabbdom */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/modules/class.js\");\n/* harmony import */ var snabbdom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! snabbdom */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/modules/attributes.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/config.js\");\n\n\n\n\nfunction start(element, cfg) {\n    const patch = (0,snabbdom__WEBPACK_IMPORTED_MODULE_3__.init)([snabbdom__WEBPACK_IMPORTED_MODULE_4__.classModule, snabbdom__WEBPACK_IMPORTED_MODULE_5__.attributesModule]);\n    const opts = (0,_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element, cfg);\n    const ctrl = new _ctrl__WEBPACK_IMPORTED_MODULE_0__[\"default\"](opts, redraw);\n    const blueprint = (0,_view_main__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ctrl);\n    element.innerHTML = '';\n    let vnode = patch(element, blueprint);\n    ctrl.div = vnode.elm;\n    function redraw() {\n        vnode = patch(vnode, (0,_view_main__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ctrl));\n    }\n    return ctrl;\n}\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/main.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/path.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/path.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Path\": () => (/* binding */ Path)\n/* harmony export */ });\nclass Path {\n    constructor(path) {\n        this.path = path;\n        this.size = () => this.path.length / 2;\n        this.head = () => this.path.slice(0, 2);\n        // returns an invalid path doesn't starting from root\n        this.tail = () => new Path(this.path.slice(2));\n        this.init = () => new Path(this.path.slice(0, -2));\n        this.last = () => this.path.slice(-2);\n        this.empty = () => this.path == '';\n        this.contains = (other) => this.path.startsWith(other.path);\n        this.isChildOf = (parent) => this.init() === parent;\n        this.append = (id) => new Path(this.path + id);\n        this.equals = (other) => this.path == other.path;\n    }\n}\nPath.root = new Path('');\n//# sourceMappingURL=path.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/path.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/pgn.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/pgn.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeGame\": () => (/* binding */ makeGame),\n/* harmony export */   \"parseComments\": () => (/* binding */ parseComments)\n/* harmony export */ });\n/* harmony import */ var chessops__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! chessops */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n/* harmony import */ var chessops_compat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! chessops/compat */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/compat.js\");\n/* harmony import */ var chessops_fen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! chessops/fen */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/fen.js\");\n/* harmony import */ var chessops_pgn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chessops/pgn */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/pgn.js\");\n/* harmony import */ var chessops_san__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! chessops/san */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/san.js\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/game.js\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/path.js\");\n\n\n\n\n\n\n\nclass State {\n    constructor(pos, path, clocks) {\n        this.pos = pos;\n        this.path = path;\n        this.clocks = clocks;\n        this.clone = () => new State(this.pos.clone(), this.path, { ...this.clocks });\n    }\n}\nconst parseComments = (strings) => {\n    const comments = strings.map(chessops_pgn__WEBPACK_IMPORTED_MODULE_2__.parseComment);\n    const reduceTimes = (times) => times.reduce((last, time) => (typeof time == undefined ? last : time), undefined);\n    return {\n        texts: comments.map(c => c.text).filter(t => !!t),\n        shapes: comments.flatMap(c => c.shapes),\n        clock: reduceTimes(comments.map(c => c.clock)),\n        emt: reduceTimes(comments.map(c => c.emt)),\n    };\n};\nconst makeGame = (pgn, lichess = false) => {\n    var _a, _b;\n    const game = (0,chessops_pgn__WEBPACK_IMPORTED_MODULE_2__.parsePgn)(pgn)[0] || (0,chessops_pgn__WEBPACK_IMPORTED_MODULE_2__.parsePgn)('*')[0];\n    const start = (0,chessops_pgn__WEBPACK_IMPORTED_MODULE_2__.startingPosition)(game.headers).unwrap();\n    const fen = (0,chessops_fen__WEBPACK_IMPORTED_MODULE_3__.makeFen)(start.toSetup());\n    const comments = parseComments(game.comments || []);\n    const headers = new Map(Array.from(game.headers, ([key, value]) => [key.toLowerCase(), value]));\n    const metadata = makeMetadata(headers, lichess);\n    const initial = {\n        fen,\n        turn: start.turn,\n        check: start.isCheck(),\n        pos: start.clone(),\n        comments: comments.texts,\n        shapes: comments.shapes,\n        clocks: {\n            white: ((_a = metadata.timeControl) === null || _a === void 0 ? void 0 : _a.initial) || comments.clock,\n            black: ((_b = metadata.timeControl) === null || _b === void 0 ? void 0 : _b.initial) || comments.clock,\n        },\n    };\n    const moves = makeMoves(start, game.moves, metadata);\n    const players = makePlayers(headers, metadata);\n    return new _game__WEBPACK_IMPORTED_MODULE_0__.Game(initial, moves, players, metadata);\n};\nconst makeMoves = (start, moves, metadata) => (0,chessops_pgn__WEBPACK_IMPORTED_MODULE_2__.transform)(moves, new State(start, _path__WEBPACK_IMPORTED_MODULE_1__.Path.root, {}), (state, node, _index) => {\n    const move = (0,chessops_san__WEBPACK_IMPORTED_MODULE_4__.parseSan)(state.pos, node.san);\n    if (!move)\n        return undefined;\n    const moveId = (0,chessops_compat__WEBPACK_IMPORTED_MODULE_5__.scalachessCharPair)(move);\n    const path = state.path.append(moveId);\n    const san = (0,chessops_san__WEBPACK_IMPORTED_MODULE_4__.makeSanAndPlay)(state.pos, move);\n    state.path = path;\n    const setup = state.pos.toSetup();\n    const comments = parseComments(node.comments || []);\n    const startingComments = parseComments(node.startingComments || []);\n    const shapes = [...comments.shapes, ...startingComments.shapes];\n    const ply = (setup.fullmoves - 1) * 2 + (state.pos.turn === 'white' ? 0 : 1);\n    let clocks = (state.clocks = makeClocks(state.clocks, state.pos.turn, comments.clock));\n    if (ply < 2 && metadata.timeControl)\n        clocks = {\n            white: metadata.timeControl.initial,\n            black: metadata.timeControl.initial,\n            ...clocks,\n        };\n    const moveNode = {\n        path,\n        ply,\n        move,\n        san,\n        uci: (0,chessops__WEBPACK_IMPORTED_MODULE_6__.makeUci)(move),\n        fen: (0,chessops_fen__WEBPACK_IMPORTED_MODULE_3__.makeFen)(state.pos.toSetup()),\n        turn: state.pos.turn,\n        check: state.pos.isCheck(),\n        comments: comments.texts,\n        startingComments: startingComments.texts,\n        nags: node.nags || [],\n        shapes,\n        clocks,\n        emt: comments.emt,\n    };\n    return moveNode;\n});\nconst makeClocks = (prev, turn, clk) => turn == 'white' ? { ...prev, black: clk } : { ...prev, white: clk };\nfunction makePlayers(headers, metadata) {\n    const get = (color, field) => {\n        const raw = headers.get(`${color}${field}`);\n        return raw == '?' || raw == '' ? undefined : raw;\n    };\n    const makePlayer = (color) => {\n        const name = get(color, '');\n        return {\n            name,\n            title: get(color, 'title'),\n            rating: parseInt(get(color, 'elo') || '') || undefined,\n            isLichessUser: metadata.isLichess && !!(name === null || name === void 0 ? void 0 : name.match(/^[a-z0-9][a-z0-9_-]{0,28}[a-z0-9]$/i)),\n        };\n    };\n    return {\n        white: makePlayer('white'),\n        black: makePlayer('black'),\n    };\n}\nfunction makeMetadata(headers, lichess) {\n    var _a;\n    const site = headers.get('site');\n    const tcs = (_a = headers\n        .get('timecontrol')) === null || _a === void 0 ? void 0 : _a.split('+').map(x => parseInt(x));\n    const timeControl = tcs && tcs[0]\n        ? {\n            initial: tcs[0],\n            increment: tcs[1] || 0,\n        }\n        : undefined;\n    return {\n        externalLink: site && site.match(/^https?:\\/\\//) ? site : undefined,\n        isLichess: !!(lichess && (site === null || site === void 0 ? void 0 : site.startsWith(lichess))),\n        timeControl,\n    };\n}\n//# sourceMappingURL=pgn.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/pgn.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/translation.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/translation.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ translate)\n/* harmony export */ });\nfunction translate(translator) {\n    return (key) => (translator && translator(key)) || defaultTranslator(key);\n}\nconst defaultTranslator = (key) => defaultTranslations[key];\nconst defaultTranslations = {\n    flipTheBoard: 'Flip the board',\n    analysisBoard: 'Analysis board',\n    practiceWithComputer: 'Practice with computer',\n    getPgn: 'Get PGN',\n    download: 'Download',\n    viewOnLichess: 'View on Lichess',\n    viewOnSite: 'View on site',\n};\n//# sourceMappingURL=translation.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/translation.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/main.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/main.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ view),\n/* harmony export */   \"makeConfig\": () => (/* binding */ makeConfig)\n/* harmony export */ });\n/* harmony import */ var chessground__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chessground */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/chessground.js\");\n/* harmony import */ var snabbdom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! snabbdom */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/h.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/util.js\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/events.js\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./menu */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/menu.js\");\n/* harmony import */ var _side__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./side */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/side.js\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./player */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/player.js\");\n\n\n\n\n\n\n\nfunction view(ctrl) {\n    const opts = ctrl.opts, staticClasses = `lpv.lpv--moves-${opts.showMoves}.lpv--controls-${opts.showControls}${opts.classes ? '.' + opts.classes.replace(' ', '.') : ''}`;\n    return (0,snabbdom__WEBPACK_IMPORTED_MODULE_6__.h)(`div.${staticClasses}`, {\n        class: {\n            'lpv--menu': ctrl.pane != 'board',\n            'lpv--players': opts.showPlayers == 'auto' ? ctrl.game.hasPlayerName() : opts.showPlayers,\n        },\n        attrs: {\n            tabindex: 0,\n        },\n        hook: (0,_util__WEBPACK_IMPORTED_MODULE_1__.onInsert)(el => {\n            ctrl.setGround((0,chessground__WEBPACK_IMPORTED_MODULE_0__.Chessground)(el.querySelector('.cg-wrap'), makeConfig(ctrl, el)));\n            el.addEventListener('keydown', (0,_events__WEBPACK_IMPORTED_MODULE_2__.onKeyDown)(ctrl));\n        }),\n    }, [\n        opts.showPlayers ? (0,_player__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(ctrl, 'top') : undefined,\n        renderBoard(ctrl),\n        opts.showPlayers ? (0,_player__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(ctrl, 'bottom') : undefined,\n        opts.showControls ? (0,_menu__WEBPACK_IMPORTED_MODULE_3__.renderControls)(ctrl) : undefined,\n        opts.showMoves ? (0,_side__WEBPACK_IMPORTED_MODULE_4__.renderMoves)(ctrl) : undefined,\n        ctrl.pane == 'menu' ? (0,_menu__WEBPACK_IMPORTED_MODULE_3__.renderMenu)(ctrl) : ctrl.pane == 'pgn' ? renderPgnPane(ctrl) : undefined,\n    ]);\n}\nconst renderBoard = (ctrl) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_6__.h)('div.lpv__board', {\n    hook: (0,_util__WEBPACK_IMPORTED_MODULE_1__.onInsert)(el => {\n        el.addEventListener('click', ctrl.focus);\n        if (ctrl.opts.scrollToMove && !('ontouchstart' in window))\n            el.addEventListener('wheel', (0,_events__WEBPACK_IMPORTED_MODULE_2__.stepwiseScroll)((e, scroll) => {\n                e.preventDefault();\n                if (e.deltaY > 0 && scroll)\n                    ctrl.goTo('next', false);\n                else if (e.deltaY < 0 && scroll)\n                    ctrl.goTo('prev', false);\n            }));\n    }),\n}, (0,snabbdom__WEBPACK_IMPORTED_MODULE_6__.h)('div.cg-wrap'));\nconst renderPgnPane = (ctrl) => {\n    const blob = new Blob([ctrl.opts.pgn], { type: 'text/plain' });\n    return (0,snabbdom__WEBPACK_IMPORTED_MODULE_6__.h)('div.lpv__pgn.lpv__pane', [\n        (0,snabbdom__WEBPACK_IMPORTED_MODULE_6__.h)('a.lpv__pgn__download.lpv__fbt', {\n            attrs: {\n                href: window.URL.createObjectURL(blob),\n                download: ctrl.opts.menu.getPgn.fileName || `${ctrl.game.title()}.pgn`,\n            },\n        }, ctrl.translate('download')),\n        (0,snabbdom__WEBPACK_IMPORTED_MODULE_6__.h)('textarea.lpv__pgn__text', ctrl.opts.pgn),\n    ]);\n};\nconst makeConfig = (ctrl, rootEl) => ({\n    viewOnly: !ctrl.opts.drawArrows,\n    addDimensionsCssVarsTo: rootEl,\n    drawable: {\n        enabled: ctrl.opts.drawArrows,\n        visible: true,\n    },\n    disableContextMenu: ctrl.opts.drawArrows,\n    ...(ctrl.opts.chessground || {}),\n    ...ctrl.cgState(),\n});\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/main.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/menu.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/menu.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderControls\": () => (/* binding */ renderControls),\n/* harmony export */   \"renderMenu\": () => (/* binding */ renderMenu)\n/* harmony export */ });\n/* harmony import */ var snabbdom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! snabbdom */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/h.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/util.js\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/events.js\");\n\n\n\nconst renderMenu = (ctrl) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)('div.lpv__menu.lpv__pane', [\n    (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)('button.lpv__menu__entry.lpv__menu__flip.lpv__fbt', {\n        hook: (0,_util__WEBPACK_IMPORTED_MODULE_0__.bind)('click', ctrl.flip),\n    }, ctrl.translate('flipTheBoard')),\n    (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)('a.lpv__menu__entry.lpv__menu__analysis.lpv__fbt', {\n        attrs: {\n            href: ctrl.analysisUrl(),\n            target: '_blank',\n        },\n    }, ctrl.translate('analysisBoard')),\n    (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)('a.lpv__menu__entry.lpv__menu__practice.lpv__fbt', {\n        attrs: {\n            href: ctrl.practiceUrl(),\n            target: '_blank',\n        },\n    }, ctrl.translate('practiceWithComputer')),\n    ctrl.opts.menu.getPgn.enabled\n        ? (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)('button.lpv__menu__entry.lpv__menu__pgn.lpv__fbt', {\n            hook: (0,_util__WEBPACK_IMPORTED_MODULE_0__.bind)('click', ctrl.togglePgn),\n        }, ctrl.translate('getPgn'))\n        : undefined,\n    renderExternalLink(ctrl),\n]);\nconst renderExternalLink = (ctrl) => {\n    const link = ctrl.game.metadata.externalLink;\n    return (link &&\n        (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)('a.lpv__menu__entry.lpv__fbt', {\n            attrs: {\n                href: link,\n                target: '_blank',\n            },\n        }, ctrl.translate(ctrl.game.metadata.isLichess ? 'viewOnLichess' : 'viewOnSite')));\n};\nconst renderControls = (ctrl) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)('div.lpv__controls', [\n    ctrl.pane == 'board' ? undefined : dirButton(ctrl, 'first', 'step-backward'),\n    dirButton(ctrl, 'prev', 'left-open'),\n    (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)('button.lpv__fbt.lpv__controls__menu.lpv__icon', {\n        class: {\n            active: ctrl.pane != 'board',\n            'lpv__icon-ellipsis-vert': ctrl.pane == 'board',\n        },\n        hook: (0,_util__WEBPACK_IMPORTED_MODULE_0__.bind)('click', ctrl.toggleMenu),\n    }, ctrl.pane == 'board' ? undefined : 'X'),\n    dirButton(ctrl, 'next', 'right-open'),\n    ctrl.pane == 'board' ? undefined : dirButton(ctrl, 'last', 'step-forward'),\n]);\nconst dirButton = (ctrl, to, icon) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_2__.h)(`button.lpv__controls__goto.lpv__controls__goto--${to}.lpv__fbt.lpv__icon.lpv__icon-${icon}`, {\n    class: { disabled: ctrl.pane == 'board' && !ctrl.canGoTo(to) },\n    hook: (0,_util__WEBPACK_IMPORTED_MODULE_0__.onInsert)(el => (0,_util__WEBPACK_IMPORTED_MODULE_0__.bindMobileMousedown)(el, e => (0,_events__WEBPACK_IMPORTED_MODULE_1__.eventRepeater)(() => ctrl.goTo(to), e))),\n});\n//# sourceMappingURL=menu.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/menu.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/player.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/player.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ renderPlayer)\n/* harmony export */ });\n/* harmony import */ var chessops__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chessops */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n/* harmony import */ var snabbdom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! snabbdom */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/h.js\");\n\n\nfunction renderPlayer(ctrl, side) {\n    const color = side == 'bottom' ? ctrl.orientation() : (0,chessops__WEBPACK_IMPORTED_MODULE_0__.opposite)(ctrl.orientation());\n    const player = ctrl.game.players[color];\n    const personEls = [\n        player.title ? (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('span.lpv__player__title', player.title) : undefined,\n        (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('span.lpv__player__name', player.name),\n        player.rating ? (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('span.lpv__player__rating', ['(', player.rating, ')']) : undefined,\n    ];\n    return (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)(`div.lpv__player.lpv__player--${side}`, [\n        player.isLichessUser\n            ? (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('a.lpv__player__person.ulpt.user-link', { attrs: { href: `${ctrl.opts.lichess}/@/${player.name}` } }, personEls)\n            : (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('span.lpv__player__person', personEls),\n        ctrl.opts.showClocks ? renderClock(ctrl, color) : undefined,\n    ]);\n}\nconst renderClock = (ctrl, color) => {\n    const move = ctrl.curData();\n    const clock = move.clocks && move.clocks[color];\n    return typeof clock == undefined\n        ? undefined\n        : (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('div.lpv__player__clock', { class: { active: color == move.turn } }, clockContent(clock));\n};\nconst clockContent = (seconds) => {\n    if (!seconds && seconds !== 0)\n        return ['-'];\n    const date = new Date(seconds * 1000), sep = ':', baseStr = pad2(date.getUTCMinutes()) + sep + pad2(date.getUTCSeconds());\n    return seconds >= 3600 ? [Math.floor(seconds / 3600) + sep + baseStr] : [baseStr];\n};\nconst pad2 = (num) => (num < 10 ? '0' : '') + num;\n//# sourceMappingURL=player.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/player.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/side.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/side.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderMoves\": () => (/* binding */ renderMoves)\n/* harmony export */ });\n/* harmony import */ var snabbdom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! snabbdom */ \"./node_modules/.pnpm/snabbdom@3.5.1/node_modules/snabbdom/build/h.js\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../path */ \"./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/path.js\");\n\n\nconst renderMoves = (ctrl) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('div.lpv__side', (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('div.lpv__moves', {\n    hook: {\n        insert: vnode => {\n            const el = vnode.elm;\n            if (!ctrl.path.empty())\n                autoScroll(ctrl, el);\n            el.addEventListener('mousedown', e => {\n                const path = e.target.getAttribute('p');\n                if (path)\n                    ctrl.toPath(new _path__WEBPACK_IMPORTED_MODULE_0__.Path(path));\n            }, { passive: true });\n        },\n        postpatch: (_, vnode) => {\n            if (ctrl.autoScrollRequested) {\n                autoScroll(ctrl, vnode.elm);\n                ctrl.autoScrollRequested = false;\n            }\n        },\n    },\n}, [...ctrl.game.initial.comments.map(commentNode), ...makeMoveNodes(ctrl)]));\nconst emptyMove = () => (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('move.empty', '...');\nconst indexNode = (turn) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('index', `${turn}.`);\nconst commentNode = (comment) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('comment', comment);\nconst parenOpen = () => (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('paren.open', '(');\nconst parenClose = () => (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('paren.close', ')');\nconst moveTurn = (move) => Math.floor((move.ply - 1) / 2) + 1;\nconst makeMoveNodes = (ctrl) => {\n    const moveDom = renderMove(ctrl);\n    const elms = [];\n    let node, variations = ctrl.game.moves.children.slice(1);\n    if (ctrl.game.initial.pos.turn == 'black' && ctrl.game.mainline[0])\n        elms.push(indexNode(ctrl.game.initial.pos.fullmoves), emptyMove());\n    while ((node = (node || ctrl.game.moves).children[0])) {\n        const move = node.data;\n        const oddMove = move.ply % 2 == 1;\n        if (oddMove)\n            elms.push(indexNode(moveTurn(move)));\n        elms.push(moveDom(move));\n        const addEmptyMove = oddMove && (variations.length || move.comments.length) && node.children.length;\n        if (addEmptyMove)\n            elms.push(emptyMove());\n        move.comments.forEach(comment => elms.push(commentNode(comment)));\n        variations.forEach(variation => elms.push(makeMainVariation(moveDom, variation)));\n        if (addEmptyMove)\n            elms.push(indexNode(moveTurn(move)), emptyMove());\n        variations = node.children.slice(1);\n    }\n    return elms;\n};\nconst makeMainVariation = (moveDom, node) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('variation', [...node.data.startingComments.map(commentNode), ...makeVariationMoves(moveDom, node)]);\nconst makeVariationMoves = (moveDom, node) => {\n    let elms = [];\n    let variations = [];\n    if (node.data.ply % 2 == 0)\n        elms.push((0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('index', [moveTurn(node.data), '...']));\n    do {\n        const move = node.data;\n        if (move.ply % 2 == 1)\n            elms.push((0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('index', [moveTurn(move), '.']));\n        elms.push(moveDom(move));\n        move.comments.forEach(comment => elms.push(commentNode(comment)));\n        variations.forEach(variation => {\n            elms = [...elms, parenOpen(), ...makeVariationMoves(moveDom, variation), parenClose()];\n        });\n        variations = node.children.slice(1);\n        node = node.children[0];\n    } while (node);\n    return elms;\n};\nconst renderMove = (ctrl) => (move) => (0,snabbdom__WEBPACK_IMPORTED_MODULE_1__.h)('move', {\n    class: {\n        current: ctrl.path.equals(move.path),\n        ancestor: ctrl.path.contains(move.path),\n        good: move.nags.includes(1),\n        mistake: move.nags.includes(2),\n        brilliant: move.nags.includes(3),\n        blunder: move.nags.includes(4),\n        interesting: move.nags.includes(5),\n        inaccuracy: move.nags.includes(6),\n    },\n    attrs: {\n        p: move.path.path,\n    },\n}, move.san);\nconst autoScroll = (ctrl, cont) => {\n    const target = cont.querySelector('.current');\n    if (!target) {\n        cont.scrollTop = ctrl.path.empty() ? 0 : 99999;\n        return;\n    }\n    cont.scrollTop = target.offsetTop - cont.offsetHeight / 2 + target.offsetHeight;\n};\n//# sourceMappingURL=side.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/side.js?");

/***/ }),

/***/ "./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/util.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/util.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bind\": () => (/* binding */ bind),\n/* harmony export */   \"bindMobileMousedown\": () => (/* binding */ bindMobileMousedown),\n/* harmony export */   \"onInsert\": () => (/* binding */ onInsert)\n/* harmony export */ });\nfunction bindMobileMousedown(el, f, redraw) {\n    for (const mousedownEvent of ['touchstart', 'mousedown']) {\n        el.addEventListener(mousedownEvent, e => {\n            f(e);\n            e.preventDefault();\n            if (redraw)\n                redraw();\n        }, { passive: false });\n    }\n}\nconst bind = (eventName, f, redraw, passive = true) => onInsert(el => el.addEventListener(eventName, e => {\n    const res = f(e);\n    if (res === false)\n        e.preventDefault();\n    redraw === null || redraw === void 0 ? void 0 : redraw();\n    return res;\n}, { passive }));\nfunction onInsert(f) {\n    return {\n        insert: vnode => f(vnode.elm),\n    };\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/@ranklab-gaming+lichess-pgn-viewer@1.5.5/node_modules/@ranklab-gaming/lichess-pgn-viewer/view/util.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/anim.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/anim.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"anim\": () => (/* binding */ anim),\n/* harmony export */   \"render\": () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n\nconst anim = (mutation, state) => state.animation.enabled ? animate(mutation, state) : render(mutation, state);\nfunction render(mutation, state) {\n    const result = mutation(state);\n    state.dom.redraw();\n    return result;\n}\nconst makePiece = (key, piece) => ({\n    key: key,\n    pos: _util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos(key),\n    piece: piece,\n});\nconst closer = (piece, pieces) => pieces.sort((p1, p2) => _util_js__WEBPACK_IMPORTED_MODULE_0__.distanceSq(piece.pos, p1.pos) - _util_js__WEBPACK_IMPORTED_MODULE_0__.distanceSq(piece.pos, p2.pos))[0];\nfunction computePlan(prevPieces, current) {\n    const anims = new Map(), animedOrigs = [], fadings = new Map(), missings = [], news = [], prePieces = new Map();\n    let curP, preP, vector;\n    for (const [k, p] of prevPieces) {\n        prePieces.set(k, makePiece(k, p));\n    }\n    for (const key of _util_js__WEBPACK_IMPORTED_MODULE_0__.allKeys) {\n        curP = current.pieces.get(key);\n        preP = prePieces.get(key);\n        if (curP) {\n            if (preP) {\n                if (!_util_js__WEBPACK_IMPORTED_MODULE_0__.samePiece(curP, preP.piece)) {\n                    missings.push(preP);\n                    news.push(makePiece(key, curP));\n                }\n            }\n            else\n                news.push(makePiece(key, curP));\n        }\n        else if (preP)\n            missings.push(preP);\n    }\n    for (const newP of news) {\n        preP = closer(newP, missings.filter(p => _util_js__WEBPACK_IMPORTED_MODULE_0__.samePiece(newP.piece, p.piece)));\n        if (preP) {\n            vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];\n            anims.set(newP.key, vector.concat(vector));\n            animedOrigs.push(preP.key);\n        }\n    }\n    for (const p of missings) {\n        if (!animedOrigs.includes(p.key))\n            fadings.set(p.key, p.piece);\n    }\n    return {\n        anims: anims,\n        fadings: fadings,\n    };\n}\nfunction step(state, now) {\n    const cur = state.animation.current;\n    if (cur === undefined) {\n        // animation was canceled :(\n        if (!state.dom.destroyed)\n            state.dom.redrawNow();\n        return;\n    }\n    const rest = 1 - (now - cur.start) * cur.frequency;\n    if (rest <= 0) {\n        state.animation.current = undefined;\n        state.dom.redrawNow();\n    }\n    else {\n        const ease = easing(rest);\n        for (const cfg of cur.plan.anims.values()) {\n            cfg[2] = cfg[0] * ease;\n            cfg[3] = cfg[1] * ease;\n        }\n        state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n        requestAnimationFrame((now = performance.now()) => step(state, now));\n    }\n}\nfunction animate(mutation, state) {\n    // clone state before mutating it\n    const prevPieces = new Map(state.pieces);\n    const result = mutation(state);\n    const plan = computePlan(prevPieces, state);\n    if (plan.anims.size || plan.fadings.size) {\n        const alreadyRunning = state.animation.current && state.animation.current.start;\n        state.animation.current = {\n            start: performance.now(),\n            frequency: 1 / state.animation.duration,\n            plan: plan,\n        };\n        if (!alreadyRunning)\n            step(state, performance.now());\n    }\n    else {\n        // don't animate, just render right away\n        state.dom.redraw();\n    }\n    return result;\n}\n// https://gist.github.com/gre/1650294\nconst easing = (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);\n//# sourceMappingURL=anim.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/anim.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/api.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/api.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"start\": () => (/* binding */ start)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js\");\n/* harmony import */ var _fen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fen.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/fen.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/config.js\");\n/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anim.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/anim.js\");\n/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drag.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drag.js\");\n/* harmony import */ var _explosion_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./explosion.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/explosion.js\");\n\n\n\n\n\n\n// see API types and documentations in dts/api.d.ts\nfunction start(state, redrawAll) {\n    function toggleOrientation() {\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.toggleOrientation(state);\n        redrawAll();\n    }\n    return {\n        set(config) {\n            if (config.orientation && config.orientation !== state.orientation)\n                toggleOrientation();\n            (0,_config_js__WEBPACK_IMPORTED_MODULE_2__.applyAnimation)(state, config);\n            (config.fen ? _anim_js__WEBPACK_IMPORTED_MODULE_3__.anim : _anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => (0,_config_js__WEBPACK_IMPORTED_MODULE_2__.configure)(state, config), state);\n        },\n        state,\n        getFen: () => (0,_fen_js__WEBPACK_IMPORTED_MODULE_1__.write)(state.pieces),\n        toggleOrientation,\n        setPieces(pieces) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.setPieces(state, pieces), state);\n        },\n        selectSquare(key, force) {\n            if (key)\n                (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.selectSquare(state, key, force), state);\n            else if (state.selected) {\n                _board_js__WEBPACK_IMPORTED_MODULE_0__.unselect(state);\n                state.dom.redraw();\n            }\n        },\n        move(orig, dest) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.baseMove(state, orig, dest), state);\n        },\n        newPiece(piece, key) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.baseNewPiece(state, piece, key), state);\n        },\n        playPremove() {\n            if (state.premovable.current) {\n                if ((0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(_board_js__WEBPACK_IMPORTED_MODULE_0__.playPremove, state))\n                    return true;\n                // if the premove couldn't be played, redraw to clear it up\n                state.dom.redraw();\n            }\n            return false;\n        },\n        playPredrop(validate) {\n            if (state.predroppable.current) {\n                const result = _board_js__WEBPACK_IMPORTED_MODULE_0__.playPredrop(state, validate);\n                state.dom.redraw();\n                return result;\n            }\n            return false;\n        },\n        cancelPremove() {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(_board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPremove, state);\n        },\n        cancelPredrop() {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(_board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPredrop, state);\n        },\n        cancelMove() {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => {\n                _board_js__WEBPACK_IMPORTED_MODULE_0__.cancelMove(state);\n                (0,_drag_js__WEBPACK_IMPORTED_MODULE_4__.cancel)(state);\n            }, state);\n        },\n        stop() {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => {\n                _board_js__WEBPACK_IMPORTED_MODULE_0__.stop(state);\n                (0,_drag_js__WEBPACK_IMPORTED_MODULE_4__.cancel)(state);\n            }, state);\n        },\n        explode(keys) {\n            (0,_explosion_js__WEBPACK_IMPORTED_MODULE_5__.explosion)(state, keys);\n        },\n        setAutoShapes(shapes) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => (state.drawable.autoShapes = shapes), state);\n        },\n        setShapes(shapes) {\n            (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.render)(state => (state.drawable.shapes = shapes), state);\n        },\n        getKeyAtDomPos(pos) {\n            return _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(pos, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(state), state.dom.bounds());\n        },\n        redrawAll,\n        dragNewPiece(piece, event, force) {\n            (0,_drag_js__WEBPACK_IMPORTED_MODULE_4__.dragNewPiece)(state, piece, event, force);\n        },\n        destroy() {\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.stop(state);\n            state.dom.unbind && state.dom.unbind();\n            state.dom.destroyed = true;\n        },\n    };\n}\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/api.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/autoPieces.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/autoPieces.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"renderResized\": () => (/* binding */ renderResized)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js\");\n/* harmony import */ var _sync_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sync.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/sync.js\");\n\n\n\nfunction render(state, autoPieceEl) {\n    const autoPieces = state.drawable.autoShapes.filter(autoShape => autoShape.piece);\n    const autoPieceShapes = autoPieces.map((s) => {\n        return {\n            shape: s,\n            hash: hash(s),\n            current: false,\n        };\n    });\n    (0,_sync_js__WEBPACK_IMPORTED_MODULE_2__.syncShapes)(autoPieceShapes, autoPieceEl, shape => renderShape(state, shape, state.dom.bounds()));\n}\nfunction renderResized(state) {\n    var _a;\n    const asWhite = (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.whitePov)(state), posToTranslate = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.posToTranslate)(state.dom.bounds());\n    let el = (_a = state.dom.elements.autoPieces) === null || _a === void 0 ? void 0 : _a.firstChild;\n    while (el) {\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translateAndScale)(el, posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(el.cgKey), asWhite), el.cgScale);\n        el = el.nextSibling;\n    }\n}\nfunction renderShape(state, { shape, hash }, bounds) {\n    var _a, _b, _c;\n    const orig = shape.orig;\n    const role = (_a = shape.piece) === null || _a === void 0 ? void 0 : _a.role;\n    const color = (_b = shape.piece) === null || _b === void 0 ? void 0 : _b.color;\n    const scale = (_c = shape.piece) === null || _c === void 0 ? void 0 : _c.scale;\n    const pieceEl = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('piece', `${role} ${color}`);\n    pieceEl.setAttribute('cgHash', hash);\n    pieceEl.cgKey = orig;\n    pieceEl.cgScale = scale;\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translateAndScale)(pieceEl, (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.posToTranslate)(bounds)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(orig), (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.whitePov)(state)), scale);\n    return pieceEl;\n}\nconst hash = (autoPiece) => { var _a, _b, _c; return [autoPiece.orig, (_a = autoPiece.piece) === null || _a === void 0 ? void 0 : _a.role, (_b = autoPiece.piece) === null || _b === void 0 ? void 0 : _b.color, (_c = autoPiece.piece) === null || _c === void 0 ? void 0 : _c.scale].join(','); };\n//# sourceMappingURL=autoPieces.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/autoPieces.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"baseMove\": () => (/* binding */ baseMove),\n/* harmony export */   \"baseNewPiece\": () => (/* binding */ baseNewPiece),\n/* harmony export */   \"callUserFunction\": () => (/* binding */ callUserFunction),\n/* harmony export */   \"canMove\": () => (/* binding */ canMove),\n/* harmony export */   \"cancelMove\": () => (/* binding */ cancelMove),\n/* harmony export */   \"dropNewPiece\": () => (/* binding */ dropNewPiece),\n/* harmony export */   \"getKeyAtDomPos\": () => (/* binding */ getKeyAtDomPos),\n/* harmony export */   \"getSnappedKeyAtDomPos\": () => (/* binding */ getSnappedKeyAtDomPos),\n/* harmony export */   \"isDraggable\": () => (/* binding */ isDraggable),\n/* harmony export */   \"playPredrop\": () => (/* binding */ playPredrop),\n/* harmony export */   \"playPremove\": () => (/* binding */ playPremove),\n/* harmony export */   \"reset\": () => (/* binding */ reset),\n/* harmony export */   \"selectSquare\": () => (/* binding */ selectSquare),\n/* harmony export */   \"setCheck\": () => (/* binding */ setCheck),\n/* harmony export */   \"setPieces\": () => (/* binding */ setPieces),\n/* harmony export */   \"setSelected\": () => (/* binding */ setSelected),\n/* harmony export */   \"stop\": () => (/* binding */ stop),\n/* harmony export */   \"toggleOrientation\": () => (/* binding */ toggleOrientation),\n/* harmony export */   \"unselect\": () => (/* binding */ unselect),\n/* harmony export */   \"unsetPredrop\": () => (/* binding */ unsetPredrop),\n/* harmony export */   \"unsetPremove\": () => (/* binding */ unsetPremove),\n/* harmony export */   \"userMove\": () => (/* binding */ userMove),\n/* harmony export */   \"whitePov\": () => (/* binding */ whitePov)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _premove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./premove.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/premove.js\");\n\n\nfunction callUserFunction(f, ...args) {\n    if (f)\n        setTimeout(() => f(...args), 1);\n}\nfunction toggleOrientation(state) {\n    state.orientation = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.opposite)(state.orientation);\n    state.animation.current = state.draggable.current = state.selected = undefined;\n}\nfunction reset(state) {\n    state.lastMove = undefined;\n    unselect(state);\n    unsetPremove(state);\n    unsetPredrop(state);\n}\nfunction setPieces(state, pieces) {\n    for (const [key, piece] of pieces) {\n        if (piece)\n            state.pieces.set(key, piece);\n        else\n            state.pieces.delete(key);\n    }\n}\nfunction setCheck(state, color) {\n    state.check = undefined;\n    if (color === true)\n        color = state.turnColor;\n    if (color)\n        for (const [k, p] of state.pieces) {\n            if (p.role === 'king' && p.color === color) {\n                state.check = k;\n            }\n        }\n}\nfunction setPremove(state, orig, dest, meta) {\n    unsetPredrop(state);\n    state.premovable.current = [orig, dest];\n    callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\nfunction unsetPremove(state) {\n    if (state.premovable.current) {\n        state.premovable.current = undefined;\n        callUserFunction(state.premovable.events.unset);\n    }\n}\nfunction setPredrop(state, role, key) {\n    unsetPremove(state);\n    state.predroppable.current = { role, key };\n    callUserFunction(state.predroppable.events.set, role, key);\n}\nfunction unsetPredrop(state) {\n    const pd = state.predroppable;\n    if (pd.current) {\n        pd.current = undefined;\n        callUserFunction(pd.events.unset);\n    }\n}\nfunction tryAutoCastle(state, orig, dest) {\n    if (!state.autoCastle)\n        return false;\n    const king = state.pieces.get(orig);\n    if (!king || king.role !== 'king')\n        return false;\n    const origPos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(orig);\n    const destPos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(dest);\n    if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1])\n        return false;\n    if (origPos[0] === 4 && !state.pieces.has(dest)) {\n        if (destPos[0] === 6)\n            dest = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([7, destPos[1]]);\n        else if (destPos[0] === 2)\n            dest = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([0, destPos[1]]);\n    }\n    const rook = state.pieces.get(dest);\n    if (!rook || rook.color !== king.color || rook.role !== 'rook')\n        return false;\n    state.pieces.delete(orig);\n    state.pieces.delete(dest);\n    if (origPos[0] < destPos[0]) {\n        state.pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([6, destPos[1]]), king);\n        state.pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([5, destPos[1]]), rook);\n    }\n    else {\n        state.pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([2, destPos[1]]), king);\n        state.pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([3, destPos[1]]), rook);\n    }\n    return true;\n}\nfunction baseMove(state, orig, dest) {\n    const origPiece = state.pieces.get(orig), destPiece = state.pieces.get(dest);\n    if (orig === dest || !origPiece)\n        return false;\n    const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n    if (dest === state.selected)\n        unselect(state);\n    callUserFunction(state.events.move, orig, dest, captured);\n    if (!tryAutoCastle(state, orig, dest)) {\n        state.pieces.set(dest, origPiece);\n        state.pieces.delete(orig);\n    }\n    state.lastMove = [orig, dest];\n    state.check = undefined;\n    callUserFunction(state.events.change);\n    return captured || true;\n}\nfunction baseNewPiece(state, piece, key, force) {\n    if (state.pieces.has(key)) {\n        if (force)\n            state.pieces.delete(key);\n        else\n            return false;\n    }\n    callUserFunction(state.events.dropNewPiece, piece, key);\n    state.pieces.set(key, piece);\n    state.lastMove = [key];\n    state.check = undefined;\n    callUserFunction(state.events.change);\n    state.movable.dests = undefined;\n    state.turnColor = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.opposite)(state.turnColor);\n    return true;\n}\nfunction baseUserMove(state, orig, dest) {\n    const result = baseMove(state, orig, dest);\n    if (result) {\n        state.movable.dests = undefined;\n        state.turnColor = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.opposite)(state.turnColor);\n        state.animation.current = undefined;\n    }\n    return result;\n}\nfunction userMove(state, orig, dest) {\n    if (canMove(state, orig, dest)) {\n        const result = baseUserMove(state, orig, dest);\n        if (result) {\n            const holdTime = state.hold.stop();\n            unselect(state);\n            const metadata = {\n                premove: false,\n                ctrlKey: state.stats.ctrlKey,\n                holdTime,\n            };\n            if (result !== true)\n                metadata.captured = result;\n            callUserFunction(state.movable.events.after, orig, dest, metadata);\n            return true;\n        }\n    }\n    else if (canPremove(state, orig, dest)) {\n        setPremove(state, orig, dest, {\n            ctrlKey: state.stats.ctrlKey,\n        });\n        unselect(state);\n        return true;\n    }\n    unselect(state);\n    return false;\n}\nfunction dropNewPiece(state, orig, dest, force) {\n    const piece = state.pieces.get(orig);\n    if (piece && (canDrop(state, orig, dest) || force)) {\n        state.pieces.delete(orig);\n        baseNewPiece(state, piece, dest, force);\n        callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n            premove: false,\n            predrop: false,\n        });\n    }\n    else if (piece && canPredrop(state, orig, dest)) {\n        setPredrop(state, piece.role, dest);\n    }\n    else {\n        unsetPremove(state);\n        unsetPredrop(state);\n    }\n    state.pieces.delete(orig);\n    unselect(state);\n}\nfunction selectSquare(state, key, force) {\n    callUserFunction(state.events.select, key);\n    if (state.selected) {\n        if (state.selected === key && !state.draggable.enabled) {\n            unselect(state);\n            state.hold.cancel();\n            return;\n        }\n        else if ((state.selectable.enabled || force) && state.selected !== key) {\n            if (userMove(state, state.selected, key)) {\n                state.stats.dragged = false;\n                return;\n            }\n        }\n    }\n    if ((state.selectable.enabled || state.draggable.enabled) && (isMovable(state, key) || isPremovable(state, key))) {\n        setSelected(state, key);\n        state.hold.start();\n    }\n}\nfunction setSelected(state, key) {\n    state.selected = key;\n    if (isPremovable(state, key)) {\n        state.premovable.dests = (0,_premove_js__WEBPACK_IMPORTED_MODULE_1__.premove)(state.pieces, key, state.premovable.castle);\n    }\n    else\n        state.premovable.dests = undefined;\n}\nfunction unselect(state) {\n    state.selected = undefined;\n    state.premovable.dests = undefined;\n    state.hold.cancel();\n}\nfunction isMovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        (state.movable.color === 'both' || (state.movable.color === piece.color && state.turnColor === piece.color)));\n}\nconst canMove = (state, orig, dest) => { var _a, _b; return orig !== dest && isMovable(state, orig) && (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest))); };\nfunction canDrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        (orig === dest || !state.pieces.has(dest)) &&\n        (state.movable.color === 'both' || (state.movable.color === piece.color && state.turnColor === piece.color)));\n}\nfunction isPremovable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;\n}\nconst canPremove = (state, orig, dest) => orig !== dest && isPremovable(state, orig) && (0,_premove_js__WEBPACK_IMPORTED_MODULE_1__.premove)(state.pieces, orig, state.premovable.castle).includes(dest);\nfunction canPredrop(state, orig, dest) {\n    const piece = state.pieces.get(orig);\n    const destPiece = state.pieces.get(dest);\n    return (!!piece &&\n        (!destPiece || destPiece.color !== state.movable.color) &&\n        state.predroppable.enabled &&\n        (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&\n        state.movable.color === piece.color &&\n        state.turnColor !== piece.color);\n}\nfunction isDraggable(state, orig) {\n    const piece = state.pieces.get(orig);\n    return (!!piece &&\n        state.draggable.enabled &&\n        (state.movable.color === 'both' ||\n            (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled))));\n}\nfunction playPremove(state) {\n    const move = state.premovable.current;\n    if (!move)\n        return false;\n    const orig = move[0], dest = move[1];\n    let success = false;\n    if (canMove(state, orig, dest)) {\n        const result = baseUserMove(state, orig, dest);\n        if (result) {\n            const metadata = { premove: true };\n            if (result !== true)\n                metadata.captured = result;\n            callUserFunction(state.movable.events.after, orig, dest, metadata);\n            success = true;\n        }\n    }\n    unsetPremove(state);\n    return success;\n}\nfunction playPredrop(state, validate) {\n    const drop = state.predroppable.current;\n    let success = false;\n    if (!drop)\n        return false;\n    if (validate(drop)) {\n        const piece = {\n            role: drop.role,\n            color: state.movable.color,\n        };\n        if (baseNewPiece(state, piece, drop.key)) {\n            callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n                premove: false,\n                predrop: true,\n            });\n            success = true;\n        }\n    }\n    unsetPredrop(state);\n    return success;\n}\nfunction cancelMove(state) {\n    unsetPremove(state);\n    unsetPredrop(state);\n    unselect(state);\n}\nfunction stop(state) {\n    state.movable.color = state.movable.dests = state.animation.current = undefined;\n    cancelMove(state);\n}\nfunction getKeyAtDomPos(pos, asWhite, bounds) {\n    let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);\n    if (!asWhite)\n        file = 7 - file;\n    let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);\n    if (!asWhite)\n        rank = 7 - rank;\n    return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([file, rank]) : undefined;\n}\nfunction getSnappedKeyAtDomPos(orig, pos, asWhite, bounds) {\n    const origPos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(orig);\n    const validSnapPos = _util_js__WEBPACK_IMPORTED_MODULE_0__.allPos.filter(pos2 => (0,_premove_js__WEBPACK_IMPORTED_MODULE_1__.queen)(origPos[0], origPos[1], pos2[0], pos2[1]) || (0,_premove_js__WEBPACK_IMPORTED_MODULE_1__.knight)(origPos[0], origPos[1], pos2[0], pos2[1]));\n    const validSnapCenters = validSnapPos.map(pos2 => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.computeSquareCenter)((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)(pos2), asWhite, bounds));\n    const validSnapDistances = validSnapCenters.map(pos2 => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.distanceSq)(pos, pos2));\n    const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index) => (a[0] < b ? a : [b, index]), [validSnapDistances[0], 0]);\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)(validSnapPos[closestSnapIndex]);\n}\nconst whitePov = (s) => s.orientation === 'white';\n//# sourceMappingURL=board.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/chessground.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/chessground.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Chessground\": () => (/* binding */ Chessground)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/api.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/config.js\");\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./state.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/state.js\");\n/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrap.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/wrap.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/events.js\");\n/* harmony import */ var _render_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./render.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/render.js\");\n/* harmony import */ var _autoPieces_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./autoPieces.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/autoPieces.js\");\n/* harmony import */ var _svg_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./svg.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/svg.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n\n\n\n\n\n\n\n\n\nfunction Chessground(element, config) {\n    const maybeState = (0,_state_js__WEBPACK_IMPORTED_MODULE_2__.defaults)();\n    (0,_config_js__WEBPACK_IMPORTED_MODULE_1__.configure)(maybeState, config || {});\n    function redrawAll() {\n        const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n        // compute bounds from existing board element if possible\n        // this allows non-square boards from CSS to be handled (for 3D)\n        const elements = (0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.renderWrap)(element, maybeState), bounds = _util_js__WEBPACK_IMPORTED_MODULE_8__.memo(() => elements.board.getBoundingClientRect()), redrawNow = (skipSvg) => {\n            (0,_render_js__WEBPACK_IMPORTED_MODULE_5__.render)(state);\n            if (elements.autoPieces)\n                _autoPieces_js__WEBPACK_IMPORTED_MODULE_6__.render(state, elements.autoPieces);\n            if (!skipSvg && elements.svg)\n                _svg_js__WEBPACK_IMPORTED_MODULE_7__.renderSvg(state, elements.svg, elements.customSvg);\n        }, onResize = () => {\n            (0,_render_js__WEBPACK_IMPORTED_MODULE_5__.updateBounds)(state);\n            (0,_render_js__WEBPACK_IMPORTED_MODULE_5__.renderResized)(state);\n            if (elements.autoPieces)\n                _autoPieces_js__WEBPACK_IMPORTED_MODULE_6__.renderResized(state);\n        };\n        const state = maybeState;\n        state.dom = {\n            elements,\n            bounds,\n            redraw: debounceRedraw(redrawNow),\n            redrawNow,\n            unbind: prevUnbind,\n        };\n        state.drawable.prevSvgHash = '';\n        (0,_render_js__WEBPACK_IMPORTED_MODULE_5__.updateBounds)(state);\n        redrawNow(false);\n        _events_js__WEBPACK_IMPORTED_MODULE_4__.bindBoard(state, onResize);\n        if (!prevUnbind)\n            state.dom.unbind = _events_js__WEBPACK_IMPORTED_MODULE_4__.bindDocument(state, onResize);\n        state.events.insert && state.events.insert(elements);\n        return state;\n    }\n    return (0,_api_js__WEBPACK_IMPORTED_MODULE_0__.start)(redrawAll(), redrawAll);\n}\nfunction debounceRedraw(redrawNow) {\n    let redrawing = false;\n    return () => {\n        if (redrawing)\n            return;\n        redrawing = true;\n        requestAnimationFrame(() => {\n            redrawNow();\n            redrawing = false;\n        });\n    };\n}\n//# sourceMappingURL=chessground.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/chessground.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/config.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/config.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyAnimation\": () => (/* binding */ applyAnimation),\n/* harmony export */   \"configure\": () => (/* binding */ configure)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js\");\n/* harmony import */ var _fen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fen.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/fen.js\");\n\n\nfunction applyAnimation(state, config) {\n    if (config.animation) {\n        deepMerge(state.animation, config.animation);\n        // no need for such short animations\n        if ((state.animation.duration || 0) < 70)\n            state.animation.enabled = false;\n    }\n}\nfunction configure(state, config) {\n    var _a, _b, _c;\n    // don't merge destinations and autoShapes. Just override.\n    if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests)\n        state.movable.dests = undefined;\n    if ((_b = config.drawable) === null || _b === void 0 ? void 0 : _b.autoShapes)\n        state.drawable.autoShapes = [];\n    deepMerge(state, config);\n    // if a fen was provided, replace the pieces\n    if (config.fen) {\n        state.pieces = (0,_fen_js__WEBPACK_IMPORTED_MODULE_1__.read)(config.fen);\n        state.drawable.shapes = ((_c = config.drawable) === null || _c === void 0 ? void 0 : _c.shapes) || [];\n    }\n    // apply config values that could be undefined yet meaningful\n    if ('check' in config)\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.setCheck)(state, config.check || false);\n    if ('lastMove' in config && !config.lastMove)\n        state.lastMove = undefined;\n    // in case of ZH drop last move, there's a single square.\n    // if the previous last move had two squares,\n    // the merge algorithm will incorrectly keep the second square.\n    else if (config.lastMove)\n        state.lastMove = config.lastMove;\n    // fix move/premove dests\n    if (state.selected)\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.setSelected)(state, state.selected);\n    applyAnimation(state, config);\n    if (!state.movable.rookCastle && state.movable.dests) {\n        const rank = state.movable.color === 'white' ? '1' : '8', kingStartPos = ('e' + rank), dests = state.movable.dests.get(kingStartPos), king = state.pieces.get(kingStartPos);\n        if (!dests || !king || king.role !== 'king')\n            return;\n        state.movable.dests.set(kingStartPos, dests.filter(d => !(d === 'a' + rank && dests.includes(('c' + rank))) &&\n            !(d === 'h' + rank && dests.includes(('g' + rank)))));\n    }\n}\nfunction deepMerge(base, extend) {\n    for (const key in extend) {\n        if (Object.prototype.hasOwnProperty.call(extend, key)) {\n            if (Object.prototype.hasOwnProperty.call(base, key) && isPlainObject(base[key]) && isPlainObject(extend[key]))\n                deepMerge(base[key], extend[key]);\n            else\n                base[key] = extend[key];\n        }\n    }\n}\nfunction isPlainObject(o) {\n    if (typeof o !== 'object' || o === null)\n        return false;\n    const proto = Object.getPrototypeOf(o);\n    return proto === Object.prototype || proto === null;\n}\n//# sourceMappingURL=config.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/config.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drag.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drag.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cancel\": () => (/* binding */ cancel),\n/* harmony export */   \"dragNewPiece\": () => (/* binding */ dragNewPiece),\n/* harmony export */   \"end\": () => (/* binding */ end),\n/* harmony export */   \"move\": () => (/* binding */ move),\n/* harmony export */   \"start\": () => (/* binding */ start)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _draw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./draw.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/draw.js\");\n/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anim.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/anim.js\");\n\n\n\n\nfunction start(s, e) {\n    if (!e.isTrusted || (e.button !== undefined && e.button !== 0))\n        return; // only touch or left click\n    if (e.touches && e.touches.length > 1)\n        return; // support one finger touch only\n    const bounds = s.dom.bounds(), position = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e), orig = _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(position, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), bounds);\n    if (!orig)\n        return;\n    const piece = s.pieces.get(orig);\n    const previouslySelected = s.selected;\n    if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor))\n        (0,_draw_js__WEBPACK_IMPORTED_MODULE_2__.clear)(s);\n    // Prevent touch scroll and create no corresponding mouse event, if there\n    // is an intent to interact with the board.\n    if (e.cancelable !== false &&\n        (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position)))\n        e.preventDefault();\n    const hadPremove = !!s.premovable.current;\n    const hadPredrop = !!s.predroppable.current;\n    s.stats.ctrlKey = e.ctrlKey;\n    if (s.selected && _board_js__WEBPACK_IMPORTED_MODULE_0__.canMove(s, s.selected, orig)) {\n        (0,_anim_js__WEBPACK_IMPORTED_MODULE_3__.anim)(state => _board_js__WEBPACK_IMPORTED_MODULE_0__.selectSquare(state, orig), s);\n    }\n    else {\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.selectSquare(s, orig);\n    }\n    const stillSelected = s.selected === orig;\n    const element = pieceElementByKey(s, orig);\n    if (piece && element && stillSelected && _board_js__WEBPACK_IMPORTED_MODULE_0__.isDraggable(s, orig)) {\n        s.draggable.current = {\n            orig,\n            piece,\n            origPos: position,\n            pos: position,\n            started: s.draggable.autoDistance && s.stats.dragged,\n            element,\n            previouslySelected,\n            originTarget: e.target,\n            keyHasChanged: false,\n        };\n        element.cgDragging = true;\n        element.classList.add('dragging');\n        // place ghost\n        const ghost = s.dom.elements.ghost;\n        if (ghost) {\n            ghost.className = `ghost ${piece.color} ${piece.role}`;\n            _util_js__WEBPACK_IMPORTED_MODULE_1__.translate(ghost, _util_js__WEBPACK_IMPORTED_MODULE_1__.posToTranslate(bounds)(_util_js__WEBPACK_IMPORTED_MODULE_1__.key2pos(orig), _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s)));\n            _util_js__WEBPACK_IMPORTED_MODULE_1__.setVisible(ghost, true);\n        }\n        processDrag(s);\n    }\n    else {\n        if (hadPremove)\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPremove(s);\n        if (hadPredrop)\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPredrop(s);\n    }\n    s.dom.redraw();\n}\nfunction pieceCloseTo(s, pos) {\n    const asWhite = _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);\n    for (const key of s.pieces.keys()) {\n        const center = _util_js__WEBPACK_IMPORTED_MODULE_1__.computeSquareCenter(key, asWhite, bounds);\n        if (_util_js__WEBPACK_IMPORTED_MODULE_1__.distanceSq(center, pos) <= radiusSq)\n            return true;\n    }\n    return false;\n}\nfunction dragNewPiece(s, piece, e, force) {\n    const key = 'a0';\n    s.pieces.set(key, piece);\n    s.dom.redraw();\n    const position = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e);\n    s.draggable.current = {\n        orig: key,\n        piece,\n        origPos: position,\n        pos: position,\n        started: true,\n        element: () => pieceElementByKey(s, key),\n        originTarget: e.target,\n        newPiece: true,\n        force: !!force,\n        keyHasChanged: false,\n    };\n    processDrag(s);\n}\nfunction processDrag(s) {\n    requestAnimationFrame(() => {\n        var _a;\n        const cur = s.draggable.current;\n        if (!cur)\n            return;\n        // cancel animations while dragging\n        if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig))\n            s.animation.current = undefined;\n        // if moving piece is gone, cancel\n        const origPiece = s.pieces.get(cur.orig);\n        if (!origPiece || !_util_js__WEBPACK_IMPORTED_MODULE_1__.samePiece(origPiece, cur.piece))\n            cancel(s);\n        else {\n            if (!cur.started && _util_js__WEBPACK_IMPORTED_MODULE_1__.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n                cur.started = true;\n            if (cur.started) {\n                // support lazy elements\n                if (typeof cur.element === 'function') {\n                    const found = cur.element();\n                    if (!found)\n                        return;\n                    found.cgDragging = true;\n                    found.classList.add('dragging');\n                    cur.element = found;\n                }\n                const bounds = s.dom.bounds();\n                _util_js__WEBPACK_IMPORTED_MODULE_1__.translate(cur.element, [\n                    cur.pos[0] - bounds.left - bounds.width / 16,\n                    cur.pos[1] - bounds.top - bounds.height / 16,\n                ]);\n                cur.keyHasChanged || (cur.keyHasChanged = cur.orig !== _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(cur.pos, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), bounds));\n            }\n        }\n        processDrag(s);\n    });\n}\nfunction move(s, e) {\n    // support one finger touch only\n    if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n        s.draggable.current.pos = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e);\n    }\n}\nfunction end(s, e) {\n    const cur = s.draggable.current;\n    if (!cur)\n        return;\n    // create no corresponding mouse event\n    if (e.type === 'touchend' && e.cancelable !== false)\n        e.preventDefault();\n    // comparing with the origin target is an easy way to test that the end event\n    // has the same touch origin\n    if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n        s.draggable.current = undefined;\n        return;\n    }\n    _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPremove(s);\n    _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPredrop(s);\n    // touchend has no position; so use the last touchmove position instead\n    const eventPos = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e) || cur.pos;\n    const dest = _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(eventPos, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), s.dom.bounds());\n    if (dest && cur.started && cur.orig !== dest) {\n        if (cur.newPiece)\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.dropNewPiece(s, cur.orig, dest, cur.force);\n        else {\n            s.stats.ctrlKey = e.ctrlKey;\n            if (_board_js__WEBPACK_IMPORTED_MODULE_0__.userMove(s, cur.orig, dest))\n                s.stats.dragged = true;\n        }\n    }\n    else if (cur.newPiece) {\n        s.pieces.delete(cur.orig);\n    }\n    else if (s.draggable.deleteOnDropOff && !dest) {\n        s.pieces.delete(cur.orig);\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.callUserFunction(s.events.change);\n    }\n    if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.unselect(s);\n    else if (!s.selectable.enabled)\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.unselect(s);\n    removeDragElements(s);\n    s.draggable.current = undefined;\n    s.dom.redraw();\n}\nfunction cancel(s) {\n    const cur = s.draggable.current;\n    if (cur) {\n        if (cur.newPiece)\n            s.pieces.delete(cur.orig);\n        s.draggable.current = undefined;\n        _board_js__WEBPACK_IMPORTED_MODULE_0__.unselect(s);\n        removeDragElements(s);\n        s.dom.redraw();\n    }\n}\nfunction removeDragElements(s) {\n    const e = s.dom.elements;\n    if (e.ghost)\n        _util_js__WEBPACK_IMPORTED_MODULE_1__.setVisible(e.ghost, false);\n}\nfunction pieceElementByKey(s, key) {\n    let el = s.dom.elements.board.firstChild;\n    while (el) {\n        if (el.cgKey === key && el.tagName === 'PIECE')\n            return el;\n        el = el.nextSibling;\n    }\n    return;\n}\n//# sourceMappingURL=drag.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drag.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/draw.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/draw.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cancel\": () => (/* binding */ cancel),\n/* harmony export */   \"clear\": () => (/* binding */ clear),\n/* harmony export */   \"end\": () => (/* binding */ end),\n/* harmony export */   \"move\": () => (/* binding */ move),\n/* harmony export */   \"processDraw\": () => (/* binding */ processDraw),\n/* harmony export */   \"start\": () => (/* binding */ start)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n\n\nconst brushes = ['green', 'red', 'blue', 'yellow'];\nfunction start(state, e) {\n    // support one finger touch only\n    if (e.touches && e.touches.length > 1)\n        return;\n    e.stopPropagation();\n    e.preventDefault();\n    e.ctrlKey ? (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.unselect)(state) : (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.cancelMove)(state);\n    const pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition)(e), orig = (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos)(pos, (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov)(state), state.dom.bounds());\n    if (!orig)\n        return;\n    state.drawable.current = {\n        orig,\n        pos,\n        brush: eventBrush(e),\n        snapToValidMove: state.drawable.defaultSnapToValidMove,\n    };\n    processDraw(state);\n}\nfunction processDraw(state) {\n    requestAnimationFrame(() => {\n        const cur = state.drawable.current;\n        if (cur) {\n            const keyAtDomPos = (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos)(cur.pos, (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov)(state), state.dom.bounds());\n            if (!keyAtDomPos) {\n                cur.snapToValidMove = false;\n            }\n            const mouseSq = cur.snapToValidMove\n                ? (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.getSnappedKeyAtDomPos)(cur.orig, cur.pos, (0,_board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov)(state), state.dom.bounds())\n                : keyAtDomPos;\n            if (mouseSq !== cur.mouseSq) {\n                cur.mouseSq = mouseSq;\n                cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n                state.dom.redrawNow();\n            }\n            processDraw(state);\n        }\n    });\n}\nfunction move(state, e) {\n    if (state.drawable.current)\n        state.drawable.current.pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition)(e);\n}\nfunction end(state) {\n    const cur = state.drawable.current;\n    if (cur) {\n        if (cur.mouseSq)\n            addShape(state.drawable, cur);\n        cancel(state);\n    }\n}\nfunction cancel(state) {\n    if (state.drawable.current) {\n        state.drawable.current = undefined;\n        state.dom.redraw();\n    }\n}\nfunction clear(state) {\n    if (state.drawable.shapes.length) {\n        state.drawable.shapes = [];\n        state.dom.redraw();\n        onChange(state.drawable);\n    }\n}\nfunction eventBrush(e) {\n    var _a;\n    const modA = (e.shiftKey || e.ctrlKey) && (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.isRightButton)(e);\n    const modB = e.altKey || e.metaKey || ((_a = e.getModifierState) === null || _a === void 0 ? void 0 : _a.call(e, 'AltGraph'));\n    return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\nfunction addShape(drawable, cur) {\n    const sameShape = (s) => s.orig === cur.orig && s.dest === cur.dest;\n    const similar = drawable.shapes.find(sameShape);\n    if (similar)\n        drawable.shapes = drawable.shapes.filter(s => !sameShape(s));\n    if (!similar || similar.brush !== cur.brush)\n        drawable.shapes.push({\n            orig: cur.orig,\n            dest: cur.dest,\n            brush: cur.brush,\n        });\n    onChange(drawable);\n}\nfunction onChange(drawable) {\n    if (drawable.onChange)\n        drawable.onChange(drawable.shapes);\n}\n//# sourceMappingURL=draw.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/draw.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drop.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drop.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cancelDropMode\": () => (/* binding */ cancelDropMode),\n/* harmony export */   \"drop\": () => (/* binding */ drop),\n/* harmony export */   \"setDropMode\": () => (/* binding */ setDropMode)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drag.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drag.js\");\n\n\n\nfunction setDropMode(s, piece) {\n    s.dropmode = {\n        active: true,\n        piece,\n    };\n    (0,_drag_js__WEBPACK_IMPORTED_MODULE_2__.cancel)(s);\n}\nfunction cancelDropMode(s) {\n    s.dropmode = {\n        active: false,\n    };\n}\nfunction drop(s, e) {\n    if (!s.dropmode.active)\n        return;\n    _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPremove(s);\n    _board_js__WEBPACK_IMPORTED_MODULE_0__.unsetPredrop(s);\n    const piece = s.dropmode.piece;\n    if (piece) {\n        s.pieces.set('a0', piece);\n        const position = _util_js__WEBPACK_IMPORTED_MODULE_1__.eventPosition(e);\n        const dest = position && _board_js__WEBPACK_IMPORTED_MODULE_0__.getKeyAtDomPos(position, _board_js__WEBPACK_IMPORTED_MODULE_0__.whitePov(s), s.dom.bounds());\n        if (dest)\n            _board_js__WEBPACK_IMPORTED_MODULE_0__.dropNewPiece(s, 'a0', dest);\n    }\n    s.dom.redraw();\n}\n//# sourceMappingURL=drop.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drop.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/events.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/events.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bindBoard\": () => (/* binding */ bindBoard),\n/* harmony export */   \"bindDocument\": () => (/* binding */ bindDocument)\n/* harmony export */ });\n/* harmony import */ var _drag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drag.js\");\n/* harmony import */ var _draw_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/draw.js\");\n/* harmony import */ var _drop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drop.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/drop.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n\n\n\n\nfunction bindBoard(s, onResize) {\n    const boardEl = s.dom.elements.board;\n    if ('ResizeObserver' in window)\n        new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n    if (s.disableContextMenu || s.drawable.enabled) {\n        boardEl.addEventListener('contextmenu', e => e.preventDefault());\n    }\n    if (s.viewOnly)\n        return;\n    // Cannot be passive, because we prevent touch scrolling and dragging of\n    // selected elements.\n    const onStart = startDragOrDraw(s);\n    boardEl.addEventListener('touchstart', onStart, {\n        passive: false,\n    });\n    boardEl.addEventListener('mousedown', onStart, {\n        passive: false,\n    });\n}\n// returns the unbind function\nfunction bindDocument(s, onResize) {\n    const unbinds = [];\n    // Old versions of Edge and Safari do not support ResizeObserver. Send\n    // chessground.resize if a user action has changed the bounds of the board.\n    if (!('ResizeObserver' in window))\n        unbinds.push(unbindable(document.body, 'chessground.resize', onResize));\n    if (!s.viewOnly) {\n        const onmove = dragOrDraw(s, _drag_js__WEBPACK_IMPORTED_MODULE_0__.move, _draw_js__WEBPACK_IMPORTED_MODULE_1__.move);\n        const onend = dragOrDraw(s, _drag_js__WEBPACK_IMPORTED_MODULE_0__.end, _draw_js__WEBPACK_IMPORTED_MODULE_1__.end);\n        for (const ev of ['touchmove', 'mousemove'])\n            unbinds.push(unbindable(document, ev, onmove));\n        for (const ev of ['touchend', 'mouseup'])\n            unbinds.push(unbindable(document, ev, onend));\n        const onScroll = () => s.dom.bounds.clear();\n        unbinds.push(unbindable(document, 'scroll', onScroll, { capture: true, passive: true }));\n        unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));\n    }\n    return () => unbinds.forEach(f => f());\n}\nfunction unbindable(el, eventName, callback, options) {\n    el.addEventListener(eventName, callback, options);\n    return () => el.removeEventListener(eventName, callback, options);\n}\nconst startDragOrDraw = (s) => e => {\n    if (s.draggable.current)\n        _drag_js__WEBPACK_IMPORTED_MODULE_0__.cancel(s);\n    else if (s.drawable.current)\n        _draw_js__WEBPACK_IMPORTED_MODULE_1__.cancel(s);\n    else if (e.shiftKey || (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.isRightButton)(e)) {\n        if (s.drawable.enabled)\n            _draw_js__WEBPACK_IMPORTED_MODULE_1__.start(s, e);\n    }\n    else if (!s.viewOnly) {\n        if (s.dropmode.active)\n            (0,_drop_js__WEBPACK_IMPORTED_MODULE_2__.drop)(s, e);\n        else\n            _drag_js__WEBPACK_IMPORTED_MODULE_0__.start(s, e);\n    }\n};\nconst dragOrDraw = (s, withDrag, withDraw) => e => {\n    if (s.drawable.current) {\n        if (s.drawable.enabled)\n            withDraw(s, e);\n    }\n    else if (!s.viewOnly)\n        withDrag(s, e);\n};\n//# sourceMappingURL=events.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/events.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/explosion.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/explosion.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"explosion\": () => (/* binding */ explosion)\n/* harmony export */ });\nfunction explosion(state, keys) {\n    state.exploding = { stage: 1, keys };\n    state.dom.redraw();\n    setTimeout(() => {\n        setStage(state, 2);\n        setTimeout(() => setStage(state, undefined), 120);\n    }, 120);\n}\nfunction setStage(state, stage) {\n    if (state.exploding) {\n        if (stage)\n            state.exploding.stage = stage;\n        else\n            state.exploding = undefined;\n        state.dom.redraw();\n    }\n}\n//# sourceMappingURL=explosion.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/explosion.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/fen.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/fen.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initial\": () => (/* binding */ initial),\n/* harmony export */   \"read\": () => (/* binding */ read),\n/* harmony export */   \"write\": () => (/* binding */ write)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/types.js\");\n\n\nconst initial = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nconst roles = {\n    p: 'pawn',\n    r: 'rook',\n    n: 'knight',\n    b: 'bishop',\n    q: 'queen',\n    k: 'king',\n};\nconst letters = {\n    pawn: 'p',\n    rook: 'r',\n    knight: 'n',\n    bishop: 'b',\n    queen: 'q',\n    king: 'k',\n};\nfunction read(fen) {\n    if (fen === 'start')\n        fen = initial;\n    const pieces = new Map();\n    let row = 7, col = 0;\n    for (const c of fen) {\n        switch (c) {\n            case ' ':\n            case '[':\n                return pieces;\n            case '/':\n                --row;\n                if (row < 0)\n                    return pieces;\n                col = 0;\n                break;\n            case '~': {\n                const piece = pieces.get((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([col - 1, row]));\n                if (piece)\n                    piece.promoted = true;\n                break;\n            }\n            default: {\n                const nb = c.charCodeAt(0);\n                if (nb < 57)\n                    col += nb - 48;\n                else {\n                    const role = c.toLowerCase();\n                    pieces.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key)([col, row]), {\n                        role: roles[role],\n                        color: c === role ? 'black' : 'white',\n                    });\n                    ++col;\n                }\n            }\n        }\n    }\n    return pieces;\n}\nfunction write(pieces) {\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.invRanks.map(y => _types_js__WEBPACK_IMPORTED_MODULE_1__.files.map(x => {\n        const piece = pieces.get((x + y));\n        if (piece) {\n            let p = letters[piece.role];\n            if (piece.color === 'white')\n                p = p.toUpperCase();\n            if (piece.promoted)\n                p += '~';\n            return p;\n        }\n        else\n            return '1';\n    })\n        .join(''))\n        .join('/')\n        .replace(/1{2,}/g, s => s.length.toString());\n}\n//# sourceMappingURL=fen.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/fen.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/premove.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/premove.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"knight\": () => (/* binding */ knight),\n/* harmony export */   \"premove\": () => (/* binding */ premove),\n/* harmony export */   \"queen\": () => (/* binding */ queen)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n\nconst diff = (a, b) => Math.abs(a - b);\nconst pawn = (color) => (x1, y1, x2, y2) => diff(x1, x2) < 2 &&\n    (color === 'white'\n        ? // allow 2 squares from first two ranks, for horde\n            y2 === y1 + 1 || (y1 <= 1 && y2 === y1 + 2 && x1 === x2)\n        : y2 === y1 - 1 || (y1 >= 6 && y2 === y1 - 2 && x1 === x2));\nconst knight = (x1, y1, x2, y2) => {\n    const xd = diff(x1, x2);\n    const yd = diff(y1, y2);\n    return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);\n};\nconst bishop = (x1, y1, x2, y2) => {\n    return diff(x1, x2) === diff(y1, y2);\n};\nconst rook = (x1, y1, x2, y2) => {\n    return x1 === x2 || y1 === y2;\n};\nconst queen = (x1, y1, x2, y2) => {\n    return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);\n};\nconst king = (color, rookFiles, canCastle) => (x1, y1, x2, y2) => (diff(x1, x2) < 2 && diff(y1, y2) < 2) ||\n    (canCastle &&\n        y1 === y2 &&\n        y1 === (color === 'white' ? 0 : 7) &&\n        ((x1 === 4 && ((x2 === 2 && rookFiles.includes(0)) || (x2 === 6 && rookFiles.includes(7)))) ||\n            rookFiles.includes(x2)));\nfunction rookFilesOf(pieces, color) {\n    const backrank = color === 'white' ? '1' : '8';\n    const files = [];\n    for (const [key, piece] of pieces) {\n        if (key[1] === backrank && piece.color === color && piece.role === 'rook') {\n            files.push(_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos(key)[0]);\n        }\n    }\n    return files;\n}\nfunction premove(pieces, key, canCastle) {\n    const piece = pieces.get(key);\n    if (!piece)\n        return [];\n    const pos = _util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos(key), r = piece.role, mobility = r === 'pawn'\n        ? pawn(piece.color)\n        : r === 'knight'\n            ? knight\n            : r === 'bishop'\n                ? bishop\n                : r === 'rook'\n                    ? rook\n                    : r === 'queen'\n                        ? queen\n                        : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);\n    return _util_js__WEBPACK_IMPORTED_MODULE_0__.allPos.filter(pos2 => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]))\n        .map(_util_js__WEBPACK_IMPORTED_MODULE_0__.pos2key);\n}\n//# sourceMappingURL=premove.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/premove.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/render.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/render.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"renderResized\": () => (/* binding */ renderResized),\n/* harmony export */   \"updateBounds\": () => (/* binding */ updateBounds)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/board.js\");\n\n\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nfunction render(s) {\n    const asWhite = (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.whitePov)(s), posToTranslate = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.posToTranslate)(s.dom.bounds()), boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : new Map(), fadings = curAnim ? curAnim.plan.fadings : new Map(), curDrag = s.draggable.current, squares = computeSquareClasses(s), samePieces = new Set(), sameSquares = new Set(), movedPieces = new Map(), movedSquares = new Map(); // by class name\n    let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;\n    // walk over all board dom elements, apply animations and flag moved pieces\n    el = boardEl.firstChild;\n    while (el) {\n        k = el.cgKey;\n        if (isPieceNode(el)) {\n            pieceAtKey = pieces.get(k);\n            anim = anims.get(k);\n            fading = fadings.get(k);\n            elPieceName = el.cgPiece;\n            // if piece not being dragged anymore, remove dragging style\n            if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n                el.classList.remove('dragging');\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(el, posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k), asWhite));\n                el.cgDragging = false;\n            }\n            // remove fading class if it still remains\n            if (!fading && el.cgFading) {\n                el.cgFading = false;\n                el.classList.remove('fading');\n            }\n            // there is now a piece at this dom key\n            if (pieceAtKey) {\n                // continue animation if already animating and same piece\n                // (otherwise it could animate a captured piece)\n                if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n                    const pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k);\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                    el.classList.add('anim');\n                    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(el, posToTranslate(pos, asWhite));\n                }\n                else if (el.cgAnimating) {\n                    el.cgAnimating = false;\n                    el.classList.remove('anim');\n                    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(el, posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k), asWhite));\n                    if (s.addPieceZIndex)\n                        el.style.zIndex = posZIndex((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k), asWhite);\n                }\n                // same piece: flag as same\n                if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n                    samePieces.add(k);\n                }\n                // different piece: flag as moved unless it is a fading piece\n                else {\n                    if (fading && elPieceName === pieceNameOf(fading)) {\n                        el.classList.add('fading');\n                        el.cgFading = true;\n                    }\n                    else {\n                        appendValue(movedPieces, elPieceName, el);\n                    }\n                }\n            }\n            // no piece: flag as moved\n            else {\n                appendValue(movedPieces, elPieceName, el);\n            }\n        }\n        else if (isSquareNode(el)) {\n            const cn = el.className;\n            if (squares.get(k) === cn)\n                sameSquares.add(k);\n            else\n                appendValue(movedSquares, cn, el);\n        }\n        el = el.nextSibling;\n    }\n    // walk over all squares in current set, apply dom changes to moved squares\n    // or append new squares\n    for (const [sk, className] of squares) {\n        if (!sameSquares.has(sk)) {\n            sMvdset = movedSquares.get(className);\n            sMvd = sMvdset && sMvdset.pop();\n            const translation = posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(sk), asWhite);\n            if (sMvd) {\n                sMvd.cgKey = sk;\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(sMvd, translation);\n            }\n            else {\n                const squareNode = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('square', className);\n                squareNode.cgKey = sk;\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(squareNode, translation);\n                boardEl.insertBefore(squareNode, boardEl.firstChild);\n            }\n        }\n    }\n    // walk over all pieces in current set, apply dom changes to moved pieces\n    // or append new pieces\n    for (const [k, p] of pieces) {\n        anim = anims.get(k);\n        if (!samePieces.has(k)) {\n            pMvdset = movedPieces.get(pieceNameOf(p));\n            pMvd = pMvdset && pMvdset.pop();\n            // a same piece was moved\n            if (pMvd) {\n                // apply dom changes\n                pMvd.cgKey = k;\n                if (pMvd.cgFading) {\n                    pMvd.classList.remove('fading');\n                    pMvd.cgFading = false;\n                }\n                const pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k);\n                if (s.addPieceZIndex)\n                    pMvd.style.zIndex = posZIndex(pos, asWhite);\n                if (anim) {\n                    pMvd.cgAnimating = true;\n                    pMvd.classList.add('anim');\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(pMvd, posToTranslate(pos, asWhite));\n            }\n            // no piece in moved obj: insert the new piece\n            // assumes the new piece is not being dragged\n            else {\n                const pieceName = pieceNameOf(p), pieceNode = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('piece', pieceName), pos = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(k);\n                pieceNode.cgPiece = pieceName;\n                pieceNode.cgKey = k;\n                if (anim) {\n                    pieceNode.cgAnimating = true;\n                    pos[0] += anim[2];\n                    pos[1] += anim[3];\n                }\n                (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(pieceNode, posToTranslate(pos, asWhite));\n                if (s.addPieceZIndex)\n                    pieceNode.style.zIndex = posZIndex(pos, asWhite);\n                boardEl.appendChild(pieceNode);\n            }\n        }\n    }\n    // remove any element that remains in the moved sets\n    for (const nodes of movedPieces.values())\n        removeNodes(s, nodes);\n    for (const nodes of movedSquares.values())\n        removeNodes(s, nodes);\n}\nfunction renderResized(s) {\n    const asWhite = (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.whitePov)(s), posToTranslate = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.posToTranslate)(s.dom.bounds());\n    let el = s.dom.elements.board.firstChild;\n    while (el) {\n        if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.translate)(el, posToTranslate((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(el.cgKey), asWhite));\n        }\n        el = el.nextSibling;\n    }\n}\nfunction updateBounds(s) {\n    var _a, _b;\n    const bounds = s.dom.elements.wrap.getBoundingClientRect();\n    const container = s.dom.elements.container;\n    const ratio = bounds.height / bounds.width;\n    const width = (Math.floor((bounds.width * window.devicePixelRatio) / 8) * 8) / window.devicePixelRatio;\n    const height = width * ratio;\n    container.style.width = width + 'px';\n    container.style.height = height + 'px';\n    s.dom.bounds.clear();\n    (_a = s.addDimensionsCssVarsTo) === null || _a === void 0 ? void 0 : _a.style.setProperty('--cg-width', width + 'px');\n    (_b = s.addDimensionsCssVarsTo) === null || _b === void 0 ? void 0 : _b.style.setProperty('--cg-height', height + 'px');\n}\nconst isPieceNode = (el) => el.tagName === 'PIECE';\nconst isSquareNode = (el) => el.tagName === 'SQUARE';\nfunction removeNodes(s, nodes) {\n    for (const node of nodes)\n        s.dom.elements.board.removeChild(node);\n}\nfunction posZIndex(pos, asWhite) {\n    const minZ = 3;\n    const rank = pos[1];\n    const z = asWhite ? minZ + 7 - rank : minZ + rank;\n    return `${z}`;\n}\nconst pieceNameOf = (piece) => `${piece.color} ${piece.role}`;\nfunction computeSquareClasses(s) {\n    var _a;\n    const squares = new Map();\n    if (s.lastMove && s.highlight.lastMove)\n        for (const k of s.lastMove) {\n            addSquare(squares, k, 'last-move');\n        }\n    if (s.check && s.highlight.check)\n        addSquare(squares, s.check, 'check');\n    if (s.selected) {\n        addSquare(squares, s.selected, 'selected');\n        if (s.movable.showDests) {\n            const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);\n            if (dests)\n                for (const k of dests) {\n                    addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n                }\n            const pDests = s.premovable.dests;\n            if (pDests)\n                for (const k of pDests) {\n                    addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n                }\n        }\n    }\n    const premove = s.premovable.current;\n    if (premove)\n        for (const k of premove)\n            addSquare(squares, k, 'current-premove');\n    else if (s.predroppable.current)\n        addSquare(squares, s.predroppable.current.key, 'current-premove');\n    const o = s.exploding;\n    if (o)\n        for (const k of o.keys)\n            addSquare(squares, k, 'exploding' + o.stage);\n    return squares;\n}\nfunction addSquare(squares, key, klass) {\n    const classes = squares.get(key);\n    if (classes)\n        squares.set(key, `${classes} ${klass}`);\n    else\n        squares.set(key, klass);\n}\nfunction appendValue(map, key, value) {\n    const arr = map.get(key);\n    if (arr)\n        arr.push(value);\n    else\n        map.set(key, [value]);\n}\n//# sourceMappingURL=render.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/render.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/state.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/state.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaults\": () => (/* binding */ defaults)\n/* harmony export */ });\n/* harmony import */ var _fen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fen.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/fen.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n\n\nfunction defaults() {\n    return {\n        pieces: _fen_js__WEBPACK_IMPORTED_MODULE_0__.read(_fen_js__WEBPACK_IMPORTED_MODULE_0__.initial),\n        orientation: 'white',\n        turnColor: 'white',\n        coordinates: true,\n        ranksPosition: 'right',\n        autoCastle: true,\n        viewOnly: false,\n        disableContextMenu: false,\n        addPieceZIndex: false,\n        blockTouchScroll: false,\n        pieceKey: false,\n        highlight: {\n            lastMove: true,\n            check: true,\n        },\n        animation: {\n            enabled: true,\n            duration: 200,\n        },\n        movable: {\n            free: true,\n            color: 'both',\n            showDests: true,\n            events: {},\n            rookCastle: true,\n        },\n        premovable: {\n            enabled: true,\n            showDests: true,\n            castle: true,\n            events: {},\n        },\n        predroppable: {\n            enabled: false,\n            events: {},\n        },\n        draggable: {\n            enabled: true,\n            distance: 3,\n            autoDistance: true,\n            showGhost: true,\n            deleteOnDropOff: false,\n        },\n        dropmode: {\n            active: false,\n        },\n        selectable: {\n            enabled: true,\n        },\n        stats: {\n            // on touchscreen, default to \"tap-tap\" moves\n            // instead of drag\n            dragged: !('ontouchstart' in window),\n        },\n        events: {},\n        drawable: {\n            enabled: true,\n            visible: true,\n            defaultSnapToValidMove: true,\n            eraseOnClick: true,\n            shapes: [],\n            autoShapes: [],\n            brushes: {\n                green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },\n                red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },\n                blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },\n                yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },\n                paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },\n                paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },\n                paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },\n                paleGrey: {\n                    key: 'pgr',\n                    color: '#4a4a4a',\n                    opacity: 0.35,\n                    lineWidth: 15,\n                },\n            },\n            prevSvgHash: '',\n        },\n        hold: (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.timer)(),\n    };\n}\n//# sourceMappingURL=state.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/state.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/svg.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/svg.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createElement\": () => (/* binding */ createElement),\n/* harmony export */   \"renderSvg\": () => (/* binding */ renderSvg),\n/* harmony export */   \"setAttributes\": () => (/* binding */ setAttributes)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _sync_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sync.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/sync.js\");\n\n\nfunction createElement(tagName) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\nfunction renderSvg(state, svg, customSvg) {\n    const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : undefined, arrowDests = new Map(), bounds = state.dom.bounds(), nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n    for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n        if (s.dest)\n            arrowDests.set(s.dest, (arrowDests.get(s.dest) || 0) + 1);\n    }\n    const shapes = d.shapes.concat(nonPieceAutoShapes).map((s) => {\n        return {\n            shape: s,\n            current: false,\n            hash: shapeHash(s, arrowDests, false, bounds),\n        };\n    });\n    if (cur)\n        shapes.push({\n            shape: cur,\n            current: true,\n            hash: shapeHash(cur, arrowDests, true, bounds),\n        });\n    const fullHash = shapes.map(sc => sc.hash).join(';');\n    if (fullHash === state.drawable.prevSvgHash)\n        return;\n    state.drawable.prevSvgHash = fullHash;\n    /*\n      -- DOM hierarchy --\n      <svg class=\"cg-shapes\">      (<= svg)\n        <defs>\n          ...(for brushes)...\n        </defs>\n        <g>\n          ...(for arrows and circles)...\n        </g>\n      </svg>\n      <svg class=\"cg-custom-svgs\"> (<= customSvg)\n        <g>\n          ...(for custom svgs)...\n        </g>\n      </svg>\n    */\n    const defsEl = svg.querySelector('defs');\n    const shapesEl = svg.querySelector('g');\n    const customSvgsEl = customSvg.querySelector('g');\n    syncDefs(d, shapes, defsEl);\n    (0,_sync_js__WEBPACK_IMPORTED_MODULE_1__.syncShapes)(shapes.filter(s => !s.shape.customSvg), shapesEl, shape => renderShape(state, shape, d.brushes, arrowDests, bounds));\n    (0,_sync_js__WEBPACK_IMPORTED_MODULE_1__.syncShapes)(shapes.filter(s => s.shape.customSvg), customSvgsEl, shape => renderShape(state, shape, d.brushes, arrowDests, bounds));\n}\n// append only. Don't try to update/remove.\nfunction syncDefs(d, shapes, defsEl) {\n    const brushes = new Map();\n    let brush;\n    for (const s of shapes) {\n        if (s.shape.dest) {\n            brush = d.brushes[s.shape.brush];\n            if (s.shape.modifiers)\n                brush = makeCustomBrush(brush, s.shape.modifiers);\n            brushes.set(brush.key, brush);\n        }\n    }\n    const keysInDom = new Set();\n    let el = defsEl.firstChild;\n    while (el) {\n        keysInDom.add(el.getAttribute('cgKey'));\n        el = el.nextSibling;\n    }\n    for (const [key, brush] of brushes.entries()) {\n        if (!keysInDom.has(key))\n            defsEl.appendChild(renderMarker(brush));\n    }\n}\nfunction shapeHash({ orig, dest, brush, piece, modifiers, customSvg }, arrowDests, current, bounds) {\n    return [\n        bounds.width,\n        bounds.height,\n        current,\n        orig,\n        dest,\n        brush,\n        dest && (arrowDests.get(dest) || 0) > 1,\n        piece && pieceHash(piece),\n        modifiers && modifiersHash(modifiers),\n        customSvg && customSvgHash(customSvg),\n    ]\n        .filter(x => x)\n        .join(',');\n}\nfunction pieceHash(piece) {\n    return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\nfunction modifiersHash(m) {\n    return '' + (m.lineWidth || '');\n}\nfunction customSvgHash(s) {\n    // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n    let h = 0;\n    for (let i = 0; i < s.length; i++) {\n        h = ((h << 5) - h + s.charCodeAt(i)) >>> 0;\n    }\n    return 'custom-' + h.toString();\n}\nfunction renderShape(state, { shape, current, hash }, brushes, arrowDests, bounds) {\n    let el;\n    const orig = orient((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(shape.orig), state.orientation);\n    if (shape.customSvg) {\n        el = renderCustomSvg(shape.customSvg, orig, bounds);\n    }\n    else {\n        if (shape.dest) {\n            let brush = brushes[shape.brush];\n            if (shape.modifiers)\n                brush = makeCustomBrush(brush, shape.modifiers);\n            el = renderArrow(brush, orig, orient((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.key2pos)(shape.dest), state.orientation), current, (arrowDests.get(shape.dest) || 0) > 1, bounds);\n        }\n        else\n            el = renderCircle(brushes[shape.brush], orig, current, bounds);\n    }\n    el.setAttribute('cgHash', hash);\n    return el;\n}\nfunction renderCustomSvg(customSvg, pos, bounds) {\n    const [x, y] = pos2user(pos, bounds);\n    // Translate to top-left of `orig` square\n    const g = setAttributes(createElement('g'), { transform: `translate(${x},${y})` });\n    // Give 100x100 coordinate system to the user for `orig` square\n    const svg = setAttributes(createElement('svg'), { width: 1, height: 1, viewBox: '0 0 100 100' });\n    g.appendChild(svg);\n    svg.innerHTML = customSvg;\n    return g;\n}\nfunction renderCircle(brush, pos, current, bounds) {\n    const o = pos2user(pos, bounds), widths = circleWidth(), radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n    return setAttributes(createElement('circle'), {\n        stroke: brush.color,\n        'stroke-width': widths[current ? 0 : 1],\n        fill: 'none',\n        opacity: opacity(brush, current),\n        cx: o[0],\n        cy: o[1],\n        r: radius - widths[1] / 2,\n    });\n}\nfunction renderArrow(brush, orig, dest, current, shorten, bounds) {\n    const m = arrowMargin(shorten && !current), a = pos2user(orig, bounds), b = pos2user(dest, bounds), dx = b[0] - a[0], dy = b[1] - a[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;\n    return setAttributes(createElement('line'), {\n        stroke: brush.color,\n        'stroke-width': lineWidth(brush, current),\n        'stroke-linecap': 'round',\n        'marker-end': 'url(#arrowhead-' + brush.key + ')',\n        opacity: opacity(brush, current),\n        x1: a[0],\n        y1: a[1],\n        x2: b[0] - xo,\n        y2: b[1] - yo,\n    });\n}\nfunction renderMarker(brush) {\n    const marker = setAttributes(createElement('marker'), {\n        id: 'arrowhead-' + brush.key,\n        orient: 'auto',\n        markerWidth: 4,\n        markerHeight: 8,\n        refX: 2.05,\n        refY: 2.01,\n    });\n    marker.appendChild(setAttributes(createElement('path'), {\n        d: 'M0,0 V4 L3,2 Z',\n        fill: brush.color,\n    }));\n    marker.setAttribute('cgKey', brush.key);\n    return marker;\n}\nfunction setAttributes(el, attrs) {\n    for (const key in attrs) {\n        if (Object.prototype.hasOwnProperty.call(attrs, key))\n            el.setAttribute(key, attrs[key]);\n    }\n    return el;\n}\nfunction orient(pos, color) {\n    return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\nfunction makeCustomBrush(base, modifiers) {\n    return {\n        color: base.color,\n        opacity: Math.round(base.opacity * 10) / 10,\n        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n        key: [base.key, modifiers.lineWidth].filter(x => x).join(''),\n    };\n}\nfunction circleWidth() {\n    return [3 / 64, 4 / 64];\n}\nfunction lineWidth(brush, current) {\n    return ((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 64;\n}\nfunction opacity(brush, current) {\n    return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\nfunction arrowMargin(shorten) {\n    return (shorten ? 20 : 10) / 64;\n}\nfunction pos2user(pos, bounds) {\n    const xScale = Math.min(1, bounds.width / bounds.height);\n    const yScale = Math.min(1, bounds.height / bounds.width);\n    return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\n//# sourceMappingURL=svg.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/svg.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/sync.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/sync.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"syncShapes\": () => (/* binding */ syncShapes)\n/* harmony export */ });\n// append and remove only. No updates.\nfunction syncShapes(shapes, root, renderShape) {\n    const hashesInDom = new Map(), // by hash\n    toRemove = [];\n    for (const sc of shapes)\n        hashesInDom.set(sc.hash, false);\n    let el = root.firstChild, elHash;\n    while (el) {\n        elHash = el.getAttribute('cgHash');\n        // found a shape element that's here to stay\n        if (hashesInDom.has(elHash))\n            hashesInDom.set(elHash, true);\n        // or remove it\n        else\n            toRemove.push(el);\n        el = el.nextSibling;\n    }\n    // remove old shapes\n    for (const el of toRemove)\n        root.removeChild(el);\n    // insert shapes that are not yet in dom\n    for (const sc of shapes) {\n        if (!hashesInDom.get(sc.hash))\n            root.appendChild(renderShape(sc));\n    }\n}\n//# sourceMappingURL=sync.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/sync.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/types.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/types.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"colors\": () => (/* binding */ colors),\n/* harmony export */   \"files\": () => (/* binding */ files),\n/* harmony export */   \"ranks\": () => (/* binding */ ranks)\n/* harmony export */ });\nconst colors = ['white', 'black'];\nconst files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/types.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"allKeys\": () => (/* binding */ allKeys),\n/* harmony export */   \"allPos\": () => (/* binding */ allPos),\n/* harmony export */   \"computeSquareCenter\": () => (/* binding */ computeSquareCenter),\n/* harmony export */   \"createEl\": () => (/* binding */ createEl),\n/* harmony export */   \"distanceSq\": () => (/* binding */ distanceSq),\n/* harmony export */   \"eventPosition\": () => (/* binding */ eventPosition),\n/* harmony export */   \"invRanks\": () => (/* binding */ invRanks),\n/* harmony export */   \"isRightButton\": () => (/* binding */ isRightButton),\n/* harmony export */   \"key2pos\": () => (/* binding */ key2pos),\n/* harmony export */   \"memo\": () => (/* binding */ memo),\n/* harmony export */   \"opposite\": () => (/* binding */ opposite),\n/* harmony export */   \"pos2key\": () => (/* binding */ pos2key),\n/* harmony export */   \"posToTranslate\": () => (/* binding */ posToTranslate),\n/* harmony export */   \"samePiece\": () => (/* binding */ samePiece),\n/* harmony export */   \"setVisible\": () => (/* binding */ setVisible),\n/* harmony export */   \"timer\": () => (/* binding */ timer),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"translateAndScale\": () => (/* binding */ translateAndScale),\n/* harmony export */   \"uciToMove\": () => (/* binding */ uciToMove)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/types.js\");\n\nconst invRanks = [..._types_js__WEBPACK_IMPORTED_MODULE_0__.ranks].reverse();\nconst allKeys = Array.prototype.concat(..._types_js__WEBPACK_IMPORTED_MODULE_0__.files.map(c => _types_js__WEBPACK_IMPORTED_MODULE_0__.ranks.map(r => c + r)));\nconst pos2key = (pos) => allKeys[8 * pos[0] + pos[1]];\nconst key2pos = (k) => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];\nconst uciToMove = (uci) => {\n    if (!uci)\n        return undefined;\n    if (uci[1] === '@')\n        return [uci.slice(2, 4)];\n    return [uci.slice(0, 2), uci.slice(2, 4)];\n};\nconst allPos = allKeys.map(key2pos);\nfunction memo(f) {\n    let v;\n    const ret = () => {\n        if (v === undefined)\n            v = f();\n        return v;\n    };\n    ret.clear = () => {\n        v = undefined;\n    };\n    return ret;\n}\nconst timer = () => {\n    let startAt;\n    return {\n        start() {\n            startAt = performance.now();\n        },\n        cancel() {\n            startAt = undefined;\n        },\n        stop() {\n            if (!startAt)\n                return 0;\n            const time = performance.now() - startAt;\n            startAt = undefined;\n            return time;\n        },\n    };\n};\nconst opposite = (c) => (c === 'white' ? 'black' : 'white');\nconst distanceSq = (pos1, pos2) => {\n    const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];\n    return dx * dx + dy * dy;\n};\nconst samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;\nconst posToTranslate = (bounds) => (pos, asWhite) => [((asWhite ? pos[0] : 7 - pos[0]) * bounds.width) / 8, ((asWhite ? 7 - pos[1] : pos[1]) * bounds.height) / 8];\nconst translate = (el, pos) => {\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\nconst translateAndScale = (el, pos, scale = 1) => {\n    el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\nconst setVisible = (el, v) => {\n    el.style.visibility = v ? 'visible' : 'hidden';\n};\nconst eventPosition = (e) => {\n    var _a;\n    if (e.clientX || e.clientX === 0)\n        return [e.clientX, e.clientY];\n    if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0])\n        return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];\n    return; // touchend has no position!\n};\nconst isRightButton = (e) => e.buttons === 2 || e.button === 2;\nconst createEl = (tagName, className) => {\n    const el = document.createElement(tagName);\n    if (className)\n        el.className = className;\n    return el;\n};\nfunction computeSquareCenter(key, asWhite, bounds) {\n    const pos = key2pos(key);\n    if (!asWhite) {\n        pos[0] = 7 - pos[0];\n        pos[1] = 7 - pos[1];\n    }\n    return [\n        bounds.left + (bounds.width * pos[0]) / 8 + bounds.width / 16,\n        bounds.top + (bounds.height * (7 - pos[1])) / 8 + bounds.height / 16,\n    ];\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/wrap.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/wrap.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"renderWrap\": () => (/* binding */ renderWrap)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/util.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/types.js\");\n/* harmony import */ var _svg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./svg.js */ \"./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/svg.js\");\n\n\n\nfunction renderWrap(element, s) {\n    // .cg-wrap (element passed to Chessground)\n    //   cg-container\n    //     cg-board\n    //     svg.cg-shapes\n    //       defs\n    //       g\n    //     svg.cg-custom-svgs\n    //       g\n    //     cg-auto-pieces\n    //     coords.ranks\n    //     coords.files\n    //     piece.ghost\n    element.innerHTML = '';\n    // ensure the cg-wrap class is set\n    // so bounds calculation can use the CSS width/height values\n    // add that class yourself to the element before calling chessground\n    // for a slight performance improvement! (avoids recomputing style)\n    element.classList.add('cg-wrap');\n    for (const c of _types_js__WEBPACK_IMPORTED_MODULE_1__.colors)\n        element.classList.toggle('orientation-' + c, s.orientation === c);\n    element.classList.toggle('manipulable', !s.viewOnly);\n    const container = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('cg-container');\n    element.appendChild(container);\n    const board = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('cg-board');\n    container.appendChild(board);\n    let svg;\n    let customSvg;\n    let autoPieces;\n    if (s.drawable.visible) {\n        svg = (0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.setAttributes)((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('svg'), {\n            class: 'cg-shapes',\n            viewBox: '-4 -4 8 8',\n            preserveAspectRatio: 'xMidYMid slice',\n        });\n        svg.appendChild((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('defs'));\n        svg.appendChild((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('g'));\n        customSvg = (0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.setAttributes)((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('svg'), {\n            class: 'cg-custom-svgs',\n            viewBox: '-3.5 -3.5 8 8',\n            preserveAspectRatio: 'xMidYMid slice',\n        });\n        customSvg.appendChild((0,_svg_js__WEBPACK_IMPORTED_MODULE_2__.createElement)('g'));\n        autoPieces = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('cg-auto-pieces');\n        container.appendChild(svg);\n        container.appendChild(customSvg);\n        container.appendChild(autoPieces);\n    }\n    if (s.coordinates) {\n        const orientClass = s.orientation === 'black' ? ' black' : '';\n        const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n        container.appendChild(renderCoords(_types_js__WEBPACK_IMPORTED_MODULE_1__.ranks, 'ranks' + orientClass + ranksPositionClass));\n        container.appendChild(renderCoords(_types_js__WEBPACK_IMPORTED_MODULE_1__.files, 'files' + orientClass));\n    }\n    let ghost;\n    if (s.draggable.enabled && s.draggable.showGhost) {\n        ghost = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('piece', 'ghost');\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.setVisible)(ghost, false);\n        container.appendChild(ghost);\n    }\n    return {\n        board,\n        container,\n        wrap: element,\n        ghost,\n        svg,\n        customSvg,\n        autoPieces,\n    };\n}\nfunction renderCoords(elems, className) {\n    const el = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('coords', className);\n    let f;\n    for (const elem of elems) {\n        f = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.createEl)('coord');\n        f.textContent = elem;\n        el.appendChild(f);\n    }\n    return el;\n}\n//# sourceMappingURL=wrap.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessground@8.3.7/node_modules/chessground/wrap.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/attacks.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/attacks.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"attacks\": () => (/* binding */ attacks),\n/* harmony export */   \"between\": () => (/* binding */ between),\n/* harmony export */   \"bishopAttacks\": () => (/* binding */ bishopAttacks),\n/* harmony export */   \"kingAttacks\": () => (/* binding */ kingAttacks),\n/* harmony export */   \"knightAttacks\": () => (/* binding */ knightAttacks),\n/* harmony export */   \"pawnAttacks\": () => (/* binding */ pawnAttacks),\n/* harmony export */   \"queenAttacks\": () => (/* binding */ queenAttacks),\n/* harmony export */   \"ray\": () => (/* binding */ ray),\n/* harmony export */   \"rookAttacks\": () => (/* binding */ rookAttacks)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n/* harmony import */ var _squareSet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./squareSet.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js\");\n/**\n * Compute attacks and rays.\n *\n * These are low-level functions that can be used to implement chess rules.\n *\n * Implementation notes: Sliding attacks are computed using\n * [hyperbola quintessence](https://www.chessprogramming.org/Hyperbola_Quintessence).\n * Magic bitboards would deliver slightly faster lookups, but also require\n * initializing considerably larger attack tables. On the web, initialization\n * time is important, so the chosen method may strike a better balance.\n *\n * @packageDocumentation\n */\n\n\nconst computeRange = (square, deltas) => {\n    let range = _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.empty();\n    for (const delta of deltas) {\n        const sq = square + delta;\n        if (0 <= sq && sq < 64 && Math.abs((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(square) - (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(sq)) <= 2) {\n            range = range.with(sq);\n        }\n    }\n    return range;\n};\nconst tabulate = (f) => {\n    const table = [];\n    for (let square = 0; square < 64; square++)\n        table[square] = f(square);\n    return table;\n};\nconst KING_ATTACKS = tabulate(sq => computeRange(sq, [-9, -8, -7, -1, 1, 7, 8, 9]));\nconst KNIGHT_ATTACKS = tabulate(sq => computeRange(sq, [-17, -15, -10, -6, 6, 10, 15, 17]));\nconst PAWN_ATTACKS = {\n    white: tabulate(sq => computeRange(sq, [7, 9])),\n    black: tabulate(sq => computeRange(sq, [-7, -9])),\n};\n/**\n * Gets squares attacked or defended by a king on `square`.\n */\nconst kingAttacks = (square) => KING_ATTACKS[square];\n/**\n * Gets squares attacked or defended by a knight on `square`.\n */\nconst knightAttacks = (square) => KNIGHT_ATTACKS[square];\n/**\n * Gets squares attacked or defended by a pawn of the given `color`\n * on `square`.\n */\nconst pawnAttacks = (color, square) => PAWN_ATTACKS[color][square];\nconst FILE_RANGE = tabulate(sq => _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.fromFile((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(sq)).without(sq));\nconst RANK_RANGE = tabulate(sq => _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.fromRank((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareRank)(sq)).without(sq));\nconst DIAG_RANGE = tabulate(sq => {\n    const diag = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(134480385, 2151686160);\n    const shift = 8 * ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareRank)(sq) - (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(sq));\n    return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\nconst ANTI_DIAG_RANGE = tabulate(sq => {\n    const diag = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(270549120, 16909320);\n    const shift = 8 * ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareRank)(sq) + (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(sq) - 7);\n    return (shift >= 0 ? diag.shl64(shift) : diag.shr64(-shift)).without(sq);\n});\nconst hyperbola = (bit, range, occupied) => {\n    let forward = occupied.intersect(range);\n    let reverse = forward.bswap64(); // Assumes no more than 1 bit per rank\n    forward = forward.minus64(bit);\n    reverse = reverse.minus64(bit.bswap64());\n    return forward.xor(reverse.bswap64()).intersect(range);\n};\nconst fileAttacks = (square, occupied) => hyperbola(_squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.fromSquare(square), FILE_RANGE[square], occupied);\nconst rankAttacks = (square, occupied) => {\n    const range = RANK_RANGE[square];\n    let forward = occupied.intersect(range);\n    let reverse = forward.rbit64();\n    forward = forward.minus64(_squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.fromSquare(square));\n    reverse = reverse.minus64(_squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.fromSquare(63 - square));\n    return forward.xor(reverse.rbit64()).intersect(range);\n};\n/**\n * Gets squares attacked or defended by a bishop on `square`, given `occupied`\n * squares.\n */\nconst bishopAttacks = (square, occupied) => {\n    const bit = _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.fromSquare(square);\n    return hyperbola(bit, DIAG_RANGE[square], occupied).xor(hyperbola(bit, ANTI_DIAG_RANGE[square], occupied));\n};\n/**\n * Gets squares attacked or defended by a rook on `square`, given `occupied`\n * squares.\n */\nconst rookAttacks = (square, occupied) => fileAttacks(square, occupied).xor(rankAttacks(square, occupied));\n/**\n * Gets squares attacked or defended by a queen on `square`, given `occupied`\n * squares.\n */\nconst queenAttacks = (square, occupied) => bishopAttacks(square, occupied).xor(rookAttacks(square, occupied));\n/**\n * Gets squares attacked or defended by a `piece` on `square`, given\n * `occupied` squares.\n */\nconst attacks = (piece, square, occupied) => {\n    switch (piece.role) {\n        case 'pawn':\n            return pawnAttacks(piece.color, square);\n        case 'knight':\n            return knightAttacks(square);\n        case 'bishop':\n            return bishopAttacks(square, occupied);\n        case 'rook':\n            return rookAttacks(square, occupied);\n        case 'queen':\n            return queenAttacks(square, occupied);\n        case 'king':\n            return kingAttacks(square);\n    }\n};\n/**\n * Gets all squares of the rank, file or diagonal with the two squares\n * `a` and `b`, or an empty set if they are not aligned.\n */\nconst ray = (a, b) => {\n    const other = _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.fromSquare(b);\n    if (RANK_RANGE[a].intersects(other))\n        return RANK_RANGE[a].with(a);\n    if (ANTI_DIAG_RANGE[a].intersects(other))\n        return ANTI_DIAG_RANGE[a].with(a);\n    if (DIAG_RANGE[a].intersects(other))\n        return DIAG_RANGE[a].with(a);\n    if (FILE_RANGE[a].intersects(other))\n        return FILE_RANGE[a].with(a);\n    return _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.empty();\n};\n/**\n * Gets all squares between `a` and `b` (bounds not included), or an empty set\n * if they are not on the same rank, file or diagonal.\n */\nconst between = (a, b) => ray(a, b)\n    .intersect(_squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.full().shl64(a).xor(_squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.full().shl64(b)))\n    .withoutFirst();\n//# sourceMappingURL=attacks.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/attacks.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/board.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/board.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Board\": () => (/* binding */ Board),\n/* harmony export */   \"boardEquals\": () => (/* binding */ boardEquals)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js\");\n/* harmony import */ var _squareSet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./squareSet.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js\");\n\n\n/**\n * Piece positions on a board.\n *\n * Properties are sets of squares, like `board.occupied` for all occupied\n * squares, `board[color]` for all pieces of that color, and `board[role]`\n * for all pieces of that role. When modifying the properties directly, take\n * care to keep them consistent.\n */\nclass Board {\n    constructor() { }\n    static default() {\n        const board = new Board();\n        board.reset();\n        return board;\n    }\n    /**\n     * Resets all pieces to the default starting position for standard chess.\n     */\n    reset() {\n        this.occupied = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0xffff, 4294901760);\n        this.promoted = _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.empty();\n        this.white = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0xffff, 0);\n        this.black = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0, 4294901760);\n        this.pawn = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0xff00, 16711680);\n        this.knight = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0x42, 1107296256);\n        this.bishop = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0x24, 603979776);\n        this.rook = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0x81, 2164260864);\n        this.queen = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0x8, 134217728);\n        this.king = new _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet(0x10, 268435456);\n    }\n    static empty() {\n        const board = new Board();\n        board.clear();\n        return board;\n    }\n    clear() {\n        this.occupied = _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.empty();\n        this.promoted = _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.empty();\n        for (const color of _types_js__WEBPACK_IMPORTED_MODULE_1__.COLORS)\n            this[color] = _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.empty();\n        for (const role of _types_js__WEBPACK_IMPORTED_MODULE_1__.ROLES)\n            this[role] = _squareSet_js__WEBPACK_IMPORTED_MODULE_0__.SquareSet.empty();\n    }\n    clone() {\n        const board = new Board();\n        board.occupied = this.occupied;\n        board.promoted = this.promoted;\n        for (const color of _types_js__WEBPACK_IMPORTED_MODULE_1__.COLORS)\n            board[color] = this[color];\n        for (const role of _types_js__WEBPACK_IMPORTED_MODULE_1__.ROLES)\n            board[role] = this[role];\n        return board;\n    }\n    getColor(square) {\n        if (this.white.has(square))\n            return 'white';\n        if (this.black.has(square))\n            return 'black';\n        return;\n    }\n    getRole(square) {\n        for (const role of _types_js__WEBPACK_IMPORTED_MODULE_1__.ROLES) {\n            if (this[role].has(square))\n                return role;\n        }\n        return;\n    }\n    get(square) {\n        const color = this.getColor(square);\n        if (!color)\n            return;\n        const role = this.getRole(square);\n        const promoted = this.promoted.has(square);\n        return { color, role, promoted };\n    }\n    /**\n     * Removes and returns the piece from the given `square`, if any.\n     */\n    take(square) {\n        const piece = this.get(square);\n        if (piece) {\n            this.occupied = this.occupied.without(square);\n            this[piece.color] = this[piece.color].without(square);\n            this[piece.role] = this[piece.role].without(square);\n            if (piece.promoted)\n                this.promoted = this.promoted.without(square);\n        }\n        return piece;\n    }\n    /**\n     * Put `piece` onto `square`, potentially replacing an existing piece.\n     * Returns the existing piece, if any.\n     */\n    set(square, piece) {\n        const old = this.take(square);\n        this.occupied = this.occupied.with(square);\n        this[piece.color] = this[piece.color].with(square);\n        this[piece.role] = this[piece.role].with(square);\n        if (piece.promoted)\n            this.promoted = this.promoted.with(square);\n        return old;\n    }\n    has(square) {\n        return this.occupied.has(square);\n    }\n    *[Symbol.iterator]() {\n        for (const square of this.occupied) {\n            yield [square, this.get(square)];\n        }\n    }\n    pieces(color, role) {\n        return this[color].intersect(this[role]);\n    }\n    rooksAndQueens() {\n        return this.rook.union(this.queen);\n    }\n    bishopsAndQueens() {\n        return this.bishop.union(this.queen);\n    }\n    /**\n     * Finds the unique king of the given `color`, if any.\n     */\n    kingOf(color) {\n        return this.pieces(color, 'king').singleSquare();\n    }\n}\nconst boardEquals = (left, right) => left.white.equals(right.white) &&\n    left.promoted.equals(right.promoted) &&\n    _types_js__WEBPACK_IMPORTED_MODULE_1__.ROLES.every(role => left[role].equals(right[role]));\n//# sourceMappingURL=board.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/board.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/chess.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/chess.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Castles\": () => (/* binding */ Castles),\n/* harmony export */   \"Chess\": () => (/* binding */ Chess),\n/* harmony export */   \"IllegalSetup\": () => (/* binding */ IllegalSetup),\n/* harmony export */   \"Position\": () => (/* binding */ Position),\n/* harmony export */   \"PositionError\": () => (/* binding */ PositionError),\n/* harmony export */   \"castlingSide\": () => (/* binding */ castlingSide),\n/* harmony export */   \"equalsIgnoreMoves\": () => (/* binding */ equalsIgnoreMoves),\n/* harmony export */   \"isStandardMaterial\": () => (/* binding */ isStandardMaterial),\n/* harmony export */   \"isStandardMaterialSide\": () => (/* binding */ isStandardMaterialSide),\n/* harmony export */   \"normalizeMove\": () => (/* binding */ normalizeMove),\n/* harmony export */   \"pseudoDests\": () => (/* binding */ pseudoDests)\n/* harmony export */ });\n/* harmony import */ var _badrap_result__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @badrap/result */ \"./node_modules/.pnpm/@badrap+result@0.2.13/node_modules/@badrap/result/dist/index.modern.mjs\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js\");\n/* harmony import */ var _squareSet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./squareSet.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/board.js\");\n/* harmony import */ var _attacks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attacks.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/attacks.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n\n\n\n\n\n\nvar IllegalSetup;\n(function (IllegalSetup) {\n    IllegalSetup[\"Empty\"] = \"ERR_EMPTY\";\n    IllegalSetup[\"OppositeCheck\"] = \"ERR_OPPOSITE_CHECK\";\n    IllegalSetup[\"ImpossibleCheck\"] = \"ERR_IMPOSSIBLE_CHECK\";\n    IllegalSetup[\"PawnsOnBackrank\"] = \"ERR_PAWNS_ON_BACKRANK\";\n    IllegalSetup[\"Kings\"] = \"ERR_KINGS\";\n    IllegalSetup[\"Variant\"] = \"ERR_VARIANT\";\n})(IllegalSetup || (IllegalSetup = {}));\nclass PositionError extends Error {\n}\nconst attacksTo = (square, attacker, board, occupied) => board[attacker].intersect((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.rookAttacks)(square, occupied)\n    .intersect(board.rooksAndQueens())\n    .union((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.bishopAttacks)(square, occupied).intersect(board.bishopsAndQueens()))\n    .union((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.knightAttacks)(square).intersect(board.knight))\n    .union((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.kingAttacks)(square).intersect(board.king))\n    .union((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.pawnAttacks)((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(attacker), square).intersect(board.pawn)));\nclass Castles {\n    constructor() { }\n    static default() {\n        const castles = new Castles();\n        castles.unmovedRooks = _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.corners();\n        castles.rook = {\n            white: { a: 0, h: 7 },\n            black: { a: 56, h: 63 },\n        };\n        castles.path = {\n            white: { a: new _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet(0xe, 0), h: new _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet(0x60, 0) },\n            black: { a: new _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet(0, 0x0e000000), h: new _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet(0, 0x60000000) },\n        };\n        return castles;\n    }\n    static empty() {\n        const castles = new Castles();\n        castles.unmovedRooks = _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n        castles.rook = {\n            white: { a: undefined, h: undefined },\n            black: { a: undefined, h: undefined },\n        };\n        castles.path = {\n            white: { a: _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty(), h: _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty() },\n            black: { a: _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty(), h: _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty() },\n        };\n        return castles;\n    }\n    clone() {\n        const castles = new Castles();\n        castles.unmovedRooks = this.unmovedRooks;\n        castles.rook = {\n            white: { a: this.rook.white.a, h: this.rook.white.h },\n            black: { a: this.rook.black.a, h: this.rook.black.h },\n        };\n        castles.path = {\n            white: { a: this.path.white.a, h: this.path.white.h },\n            black: { a: this.path.black.a, h: this.path.black.h },\n        };\n        return castles;\n    }\n    add(color, side, king, rook) {\n        const kingTo = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.kingCastlesTo)(color, side);\n        const rookTo = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.rookCastlesTo)(color, side);\n        this.unmovedRooks = this.unmovedRooks.with(rook);\n        this.rook[color][side] = rook;\n        this.path[color][side] = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.between)(rook, rookTo)\n            .with(rookTo)\n            .union((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.between)(king, kingTo).with(kingTo))\n            .without(king)\n            .without(rook);\n    }\n    static fromSetup(setup) {\n        const castles = Castles.empty();\n        const rooks = setup.unmovedRooks.intersect(setup.board.rook);\n        for (const color of _types_js__WEBPACK_IMPORTED_MODULE_3__.COLORS) {\n            const backrank = _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.backrank(color);\n            const king = setup.board.kingOf(color);\n            if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(king) || !backrank.has(king))\n                continue;\n            const side = rooks.intersect(setup.board[color]).intersect(backrank);\n            const aSide = side.first();\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(aSide) && aSide < king)\n                castles.add(color, 'a', king, aSide);\n            const hSide = side.last();\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(hSide) && king < hSide)\n                castles.add(color, 'h', king, hSide);\n        }\n        return castles;\n    }\n    discardRook(square) {\n        if (this.unmovedRooks.has(square)) {\n            this.unmovedRooks = this.unmovedRooks.without(square);\n            for (const color of _types_js__WEBPACK_IMPORTED_MODULE_3__.COLORS) {\n                for (const side of _types_js__WEBPACK_IMPORTED_MODULE_3__.CASTLING_SIDES) {\n                    if (this.rook[color][side] === square)\n                        this.rook[color][side] = undefined;\n                }\n            }\n        }\n    }\n    discardColor(color) {\n        this.unmovedRooks = this.unmovedRooks.diff(_squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.backrank(color));\n        this.rook[color].a = undefined;\n        this.rook[color].h = undefined;\n    }\n}\nclass Position {\n    constructor(rules) {\n        this.rules = rules;\n    }\n    reset() {\n        this.board = _board_js__WEBPACK_IMPORTED_MODULE_4__.Board[\"default\"]();\n        this.pockets = undefined;\n        this.turn = 'white';\n        this.castles = Castles.default();\n        this.epSquare = undefined;\n        this.remainingChecks = undefined;\n        this.halfmoves = 0;\n        this.fullmoves = 1;\n    }\n    setupUnchecked(setup) {\n        this.board = setup.board.clone();\n        this.board.promoted = _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n        this.pockets = undefined;\n        this.turn = setup.turn;\n        this.castles = Castles.fromSetup(setup);\n        this.epSquare = validEpSquare(this, setup.epSquare);\n        this.remainingChecks = undefined;\n        this.halfmoves = setup.halfmoves;\n        this.fullmoves = setup.fullmoves;\n    }\n    // When subclassing overwrite at least:\n    //\n    // - static default()\n    // - static fromSetup()\n    // - static clone()\n    //\n    // - dests()\n    // - isVariantEnd()\n    // - variantOutcome()\n    // - hasInsufficientMaterial()\n    // - isStandardMaterial()\n    kingAttackers(square, attacker, occupied) {\n        return attacksTo(square, attacker, this.board, occupied);\n    }\n    playCaptureAt(square, captured) {\n        this.halfmoves = 0;\n        if (captured.role === 'rook')\n            this.castles.discardRook(square);\n        if (this.pockets)\n            this.pockets[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(captured.color)][captured.promoted ? 'pawn' : captured.role]++;\n    }\n    ctx() {\n        const variantEnd = this.isVariantEnd();\n        const king = this.board.kingOf(this.turn);\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(king))\n            return { king, blockers: _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty(), checkers: _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty(), variantEnd, mustCapture: false };\n        const snipers = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.rookAttacks)(king, _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty())\n            .intersect(this.board.rooksAndQueens())\n            .union((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.bishopAttacks)(king, _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty()).intersect(this.board.bishopsAndQueens()))\n            .intersect(this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn)]);\n        let blockers = _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n        for (const sniper of snipers) {\n            const b = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.between)(king, sniper).intersect(this.board.occupied);\n            if (!b.moreThanOne())\n                blockers = blockers.union(b);\n        }\n        const checkers = this.kingAttackers(king, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn), this.board.occupied);\n        return {\n            king,\n            blockers,\n            checkers,\n            variantEnd,\n            mustCapture: false,\n        };\n    }\n    clone() {\n        var _a, _b;\n        const pos = new this.constructor();\n        pos.board = this.board.clone();\n        pos.pockets = (_a = this.pockets) === null || _a === void 0 ? void 0 : _a.clone();\n        pos.turn = this.turn;\n        pos.castles = this.castles.clone();\n        pos.epSquare = this.epSquare;\n        pos.remainingChecks = (_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone();\n        pos.halfmoves = this.halfmoves;\n        pos.fullmoves = this.fullmoves;\n        return pos;\n    }\n    validate(opts) {\n        if (this.board.occupied.isEmpty())\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.err(new PositionError(IllegalSetup.Empty));\n        if (this.board.king.size() !== 2)\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.err(new PositionError(IllegalSetup.Kings));\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(this.board.kingOf(this.turn)))\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.err(new PositionError(IllegalSetup.Kings));\n        const otherKing = this.board.kingOf((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn));\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(otherKing))\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.err(new PositionError(IllegalSetup.Kings));\n        if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty())\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.err(new PositionError(IllegalSetup.OppositeCheck));\n        if (_squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.backranks().intersects(this.board.pawn))\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));\n        return (opts === null || opts === void 0 ? void 0 : opts.ignoreImpossibleCheck) ? _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.ok(undefined) : this.validateCheckers();\n    }\n    validateCheckers() {\n        const ourKing = this.board.kingOf(this.turn);\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(ourKing)) {\n            const checkers = this.kingAttackers(ourKing, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn), this.board.occupied);\n            if (checkers.nonEmpty()) {\n                if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(this.epSquare)) {\n                    // The pushed pawn must be the only checker, or it has uncovered\n                    // check by a single sliding piece.\n                    const pushedTo = this.epSquare ^ 8;\n                    const pushedFrom = this.epSquare ^ 24;\n                    if (checkers.moreThanOne() ||\n                        (checkers.first() !== pushedTo &&\n                            this.kingAttackers(ourKing, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn), this.board.occupied.without(pushedTo).with(pushedFrom)).nonEmpty()))\n                        return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.err(new PositionError(IllegalSetup.ImpossibleCheck));\n                }\n                else {\n                    // Multiple sliding checkers aligned with king.\n                    if (checkers.size() > 2 || (checkers.size() === 2 && (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.ray)(checkers.first(), checkers.last()).has(ourKing)))\n                        return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.err(new PositionError(IllegalSetup.ImpossibleCheck));\n                }\n            }\n        }\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_5__.Result.ok(undefined);\n    }\n    dropDests(_ctx) {\n        return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n    }\n    dests(square, ctx) {\n        ctx = ctx || this.ctx();\n        if (ctx.variantEnd)\n            return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n        const piece = this.board.get(square);\n        if (!piece || piece.color !== this.turn)\n            return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n        let pseudo, legal;\n        if (piece.role === 'pawn') {\n            pseudo = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.pawnAttacks)(this.turn, square).intersect(this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn)]);\n            const delta = this.turn === 'white' ? 8 : -8;\n            const step = square + delta;\n            if (0 <= step && step < 64 && !this.board.occupied.has(step)) {\n                pseudo = pseudo.with(step);\n                const canDoubleStep = this.turn === 'white' ? square < 16 : square >= 64 - 16;\n                const doubleStep = step + delta;\n                if (canDoubleStep && !this.board.occupied.has(doubleStep)) {\n                    pseudo = pseudo.with(doubleStep);\n                }\n            }\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(this.epSquare) && canCaptureEp(this, square, ctx)) {\n                const pawn = this.epSquare - delta;\n                if (ctx.checkers.isEmpty() || ctx.checkers.singleSquare() === pawn) {\n                    legal = _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.fromSquare(this.epSquare);\n                }\n            }\n        }\n        else if (piece.role === 'bishop')\n            pseudo = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.bishopAttacks)(square, this.board.occupied);\n        else if (piece.role === 'knight')\n            pseudo = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.knightAttacks)(square);\n        else if (piece.role === 'rook')\n            pseudo = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.rookAttacks)(square, this.board.occupied);\n        else if (piece.role === 'queen')\n            pseudo = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.queenAttacks)(square, this.board.occupied);\n        else\n            pseudo = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.kingAttacks)(square);\n        pseudo = pseudo.diff(this.board[this.turn]);\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(ctx.king)) {\n            if (piece.role === 'king') {\n                const occ = this.board.occupied.without(square);\n                for (const to of pseudo) {\n                    if (this.kingAttackers(to, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn), occ).nonEmpty())\n                        pseudo = pseudo.without(to);\n                }\n                return pseudo.union(castlingDest(this, 'a', ctx)).union(castlingDest(this, 'h', ctx));\n            }\n            if (ctx.checkers.nonEmpty()) {\n                const checker = ctx.checkers.singleSquare();\n                if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(checker))\n                    return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n                pseudo = pseudo.intersect((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.between)(checker, ctx.king).with(checker));\n            }\n            if (ctx.blockers.has(square))\n                pseudo = pseudo.intersect((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.ray)(square, ctx.king));\n        }\n        if (legal)\n            pseudo = pseudo.union(legal);\n        return pseudo;\n    }\n    isVariantEnd() {\n        return false;\n    }\n    variantOutcome(_ctx) {\n        return;\n    }\n    hasInsufficientMaterial(color) {\n        if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty())\n            return false;\n        if (this.board[color].intersects(this.board.knight)) {\n            return (this.board[color].size() <= 2 &&\n                this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(color)].diff(this.board.king).diff(this.board.queen).isEmpty());\n        }\n        if (this.board[color].intersects(this.board.bishop)) {\n            const sameColor = !this.board.bishop.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.darkSquares()) ||\n                !this.board.bishop.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.lightSquares());\n            return sameColor && this.board.pawn.isEmpty() && this.board.knight.isEmpty();\n        }\n        return true;\n    }\n    // The following should be identical in all subclasses\n    toSetup() {\n        var _a, _b;\n        return {\n            board: this.board.clone(),\n            pockets: (_a = this.pockets) === null || _a === void 0 ? void 0 : _a.clone(),\n            turn: this.turn,\n            unmovedRooks: this.castles.unmovedRooks,\n            epSquare: legalEpSquare(this),\n            remainingChecks: (_b = this.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),\n            halfmoves: Math.min(this.halfmoves, 150),\n            fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999),\n        };\n    }\n    isInsufficientMaterial() {\n        return _types_js__WEBPACK_IMPORTED_MODULE_3__.COLORS.every(color => this.hasInsufficientMaterial(color));\n    }\n    hasDests(ctx) {\n        ctx = ctx || this.ctx();\n        for (const square of this.board[this.turn]) {\n            if (this.dests(square, ctx).nonEmpty())\n                return true;\n        }\n        return this.dropDests(ctx).nonEmpty();\n    }\n    isLegal(move, ctx) {\n        if ((0,_types_js__WEBPACK_IMPORTED_MODULE_3__.isDrop)(move)) {\n            if (!this.pockets || this.pockets[this.turn][move.role] <= 0)\n                return false;\n            if (move.role === 'pawn' && _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.backranks().has(move.to))\n                return false;\n            return this.dropDests(ctx).has(move.to);\n        }\n        else {\n            if (move.promotion === 'pawn')\n                return false;\n            if (move.promotion === 'king' && this.rules !== 'antichess')\n                return false;\n            if (!!move.promotion !== (this.board.pawn.has(move.from) && _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.backranks().has(move.to)))\n                return false;\n            const dests = this.dests(move.from, ctx);\n            return dests.has(move.to) || dests.has(normalizeMove(this, move).to);\n        }\n    }\n    isCheck() {\n        const king = this.board.kingOf(this.turn);\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(king) && this.kingAttackers(king, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn), this.board.occupied).nonEmpty();\n    }\n    isEnd(ctx) {\n        if (ctx ? ctx.variantEnd : this.isVariantEnd())\n            return true;\n        return this.isInsufficientMaterial() || !this.hasDests(ctx);\n    }\n    isCheckmate(ctx) {\n        ctx = ctx || this.ctx();\n        return !ctx.variantEnd && ctx.checkers.nonEmpty() && !this.hasDests(ctx);\n    }\n    isStalemate(ctx) {\n        ctx = ctx || this.ctx();\n        return !ctx.variantEnd && ctx.checkers.isEmpty() && !this.hasDests(ctx);\n    }\n    outcome(ctx) {\n        const variantOutcome = this.variantOutcome(ctx);\n        if (variantOutcome)\n            return variantOutcome;\n        ctx = ctx || this.ctx();\n        if (this.isCheckmate(ctx))\n            return { winner: (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(this.turn) };\n        else if (this.isInsufficientMaterial() || this.isStalemate(ctx))\n            return { winner: undefined };\n        else\n            return;\n    }\n    allDests(ctx) {\n        ctx = ctx || this.ctx();\n        const d = new Map();\n        if (ctx.variantEnd)\n            return d;\n        for (const square of this.board[this.turn]) {\n            d.set(square, this.dests(square, ctx));\n        }\n        return d;\n    }\n    play(move) {\n        const turn = this.turn;\n        const epSquare = this.epSquare;\n        const castling = castlingSide(this, move);\n        this.epSquare = undefined;\n        this.halfmoves += 1;\n        if (turn === 'black')\n            this.fullmoves += 1;\n        this.turn = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(turn);\n        if ((0,_types_js__WEBPACK_IMPORTED_MODULE_3__.isDrop)(move)) {\n            this.board.set(move.to, { role: move.role, color: turn });\n            if (this.pockets)\n                this.pockets[turn][move.role]--;\n            if (move.role === 'pawn')\n                this.halfmoves = 0;\n        }\n        else {\n            const piece = this.board.take(move.from);\n            if (!piece)\n                return;\n            let epCapture;\n            if (piece.role === 'pawn') {\n                this.halfmoves = 0;\n                if (move.to === epSquare) {\n                    epCapture = this.board.take(move.to + (turn === 'white' ? -8 : 8));\n                }\n                const delta = move.from - move.to;\n                if (Math.abs(delta) === 16 && 8 <= move.from && move.from <= 55) {\n                    this.epSquare = (move.from + move.to) >> 1;\n                }\n                if (move.promotion) {\n                    piece.role = move.promotion;\n                    piece.promoted = !!this.pockets;\n                }\n            }\n            else if (piece.role === 'rook') {\n                this.castles.discardRook(move.from);\n            }\n            else if (piece.role === 'king') {\n                if (castling) {\n                    const rookFrom = this.castles.rook[turn][castling];\n                    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(rookFrom)) {\n                        const rook = this.board.take(rookFrom);\n                        this.board.set((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.kingCastlesTo)(turn, castling), piece);\n                        if (rook)\n                            this.board.set((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.rookCastlesTo)(turn, castling), rook);\n                    }\n                }\n                this.castles.discardColor(turn);\n            }\n            if (!castling) {\n                const capture = this.board.set(move.to, piece) || epCapture;\n                if (capture)\n                    this.playCaptureAt(move.to, capture);\n            }\n        }\n        if (this.remainingChecks) {\n            if (this.isCheck())\n                this.remainingChecks[turn] = Math.max(this.remainingChecks[turn] - 1, 0);\n        }\n    }\n}\nclass Chess extends Position {\n    constructor() {\n        super('chess');\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup, opts) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate(opts).map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n}\nconst validEpSquare = (pos, square) => {\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(square))\n        return;\n    const epRank = pos.turn === 'white' ? 5 : 2;\n    const forward = pos.turn === 'white' ? 8 : -8;\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareRank)(square) !== epRank)\n        return;\n    if (pos.board.occupied.has(square + forward))\n        return;\n    const pawn = square - forward;\n    if (!pos.board.pawn.has(pawn) || !pos.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(pos.turn)].has(pawn))\n        return;\n    return square;\n};\nconst legalEpSquare = (pos) => {\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(pos.epSquare))\n        return;\n    const ctx = pos.ctx();\n    const ourPawns = pos.board.pieces(pos.turn, 'pawn');\n    const candidates = ourPawns.intersect((0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.pawnAttacks)((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(pos.turn), pos.epSquare));\n    for (const candidate of candidates) {\n        if (pos.dests(candidate, ctx).has(pos.epSquare))\n            return pos.epSquare;\n    }\n    return;\n};\nconst canCaptureEp = (pos, pawn, ctx) => {\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(pos.epSquare))\n        return false;\n    if (!(0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.pawnAttacks)(pos.turn, pawn).has(pos.epSquare))\n        return false;\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(ctx.king))\n        return true;\n    const captured = pos.epSquare + (pos.turn === 'white' ? -8 : 8);\n    const occupied = pos.board.occupied.toggle(pawn).toggle(pos.epSquare).toggle(captured);\n    return !pos.kingAttackers(ctx.king, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(pos.turn), occupied).intersects(occupied);\n};\nconst castlingDest = (pos, side, ctx) => {\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(ctx.king) || ctx.checkers.nonEmpty())\n        return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n    const rook = pos.castles.rook[pos.turn][side];\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(rook))\n        return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n    if (pos.castles.path[pos.turn][side].intersects(pos.board.occupied))\n        return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n    const kingTo = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.kingCastlesTo)(pos.turn, side);\n    const kingPath = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.between)(ctx.king, kingTo);\n    const occ = pos.board.occupied.without(ctx.king);\n    for (const sq of kingPath) {\n        if (pos.kingAttackers(sq, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(pos.turn), occ).nonEmpty())\n            return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n    }\n    const rookTo = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.rookCastlesTo)(pos.turn, side);\n    const after = pos.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);\n    if (pos.kingAttackers(kingTo, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(pos.turn), after).nonEmpty())\n        return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n    return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.fromSquare(rook);\n};\nconst pseudoDests = (pos, square, ctx) => {\n    if (ctx.variantEnd)\n        return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n    const piece = pos.board.get(square);\n    if (!piece || piece.color !== pos.turn)\n        return _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.empty();\n    let pseudo = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_0__.attacks)(piece, square, pos.board.occupied);\n    if (piece.role === 'pawn') {\n        let captureTargets = pos.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(pos.turn)];\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(pos.epSquare))\n            captureTargets = captureTargets.with(pos.epSquare);\n        pseudo = pseudo.intersect(captureTargets);\n        const delta = pos.turn === 'white' ? 8 : -8;\n        const step = square + delta;\n        if (0 <= step && step < 64 && !pos.board.occupied.has(step)) {\n            pseudo = pseudo.with(step);\n            const canDoubleStep = pos.turn === 'white' ? square < 16 : square >= 64 - 16;\n            const doubleStep = step + delta;\n            if (canDoubleStep && !pos.board.occupied.has(doubleStep)) {\n                pseudo = pseudo.with(doubleStep);\n            }\n        }\n        return pseudo;\n    }\n    else {\n        pseudo = pseudo.diff(pos.board[pos.turn]);\n    }\n    if (square === ctx.king)\n        return pseudo.union(castlingDest(pos, 'a', ctx)).union(castlingDest(pos, 'h', ctx));\n    else\n        return pseudo;\n};\nconst equalsIgnoreMoves = (left, right) => {\n    var _a, _b;\n    return left.rules === right.rules &&\n        (0,_board_js__WEBPACK_IMPORTED_MODULE_4__.boardEquals)(left.board, right.board) &&\n        ((right.pockets && ((_a = left.pockets) === null || _a === void 0 ? void 0 : _a.equals(right.pockets))) || (!left.pockets && !right.pockets)) &&\n        left.turn === right.turn &&\n        left.castles.unmovedRooks.equals(right.castles.unmovedRooks) &&\n        legalEpSquare(left) === legalEpSquare(right) &&\n        ((right.remainingChecks && ((_b = left.remainingChecks) === null || _b === void 0 ? void 0 : _b.equals(right.remainingChecks))) ||\n            (!left.remainingChecks && !right.remainingChecks));\n};\nconst castlingSide = (pos, move) => {\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_3__.isDrop)(move))\n        return;\n    const delta = move.to - move.from;\n    if (Math.abs(delta) !== 2 && !pos.board[pos.turn].has(move.to))\n        return;\n    if (!pos.board.king.has(move.from))\n        return;\n    return delta > 0 ? 'h' : 'a';\n};\nconst normalizeMove = (pos, move) => {\n    const side = castlingSide(pos, move);\n    if (!side)\n        return move;\n    const rookFrom = pos.castles.rook[pos.turn][side];\n    return {\n        from: move.from,\n        to: (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(rookFrom) ? rookFrom : move.to,\n    };\n};\nconst isStandardMaterialSide = (board, color) => {\n    const promoted = Math.max(board.pieces(color, 'queen').size() - 1, 0) +\n        Math.max(board.pieces(color, 'rook').size() - 2, 0) +\n        Math.max(board.pieces(color, 'knight').size() - 2, 0) +\n        Math.max(board.pieces(color, 'bishop').intersect(_squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.lightSquares()).size() - 1, 0) +\n        Math.max(board.pieces(color, 'bishop').intersect(_squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.darkSquares()).size() - 1, 0);\n    return board.pieces(color, 'pawn').size() + promoted <= 8;\n};\nconst isStandardMaterial = (pos) => _types_js__WEBPACK_IMPORTED_MODULE_3__.COLORS.every(color => isStandardMaterialSide(pos.board, color));\n//# sourceMappingURL=chess.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/chess.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/compat.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/compat.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"chessgroundDests\": () => (/* binding */ chessgroundDests),\n/* harmony export */   \"chessgroundMove\": () => (/* binding */ chessgroundMove),\n/* harmony export */   \"lichessRules\": () => (/* binding */ lichessRules),\n/* harmony export */   \"lichessVariant\": () => (/* binding */ lichessVariant),\n/* harmony export */   \"scalachessCharPair\": () => (/* binding */ scalachessCharPair)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n/**\n * Compatibility with other libraries.\n *\n * Convert between the formats used by chessops,\n * [chessground](https://github.com/lichess-org/chessground),\n * and [scalachess](https://github.com/lichess-org/scalachess).\n *\n * @packageDocumentation\n */\n\n\n/**\n * Computes the legal move destinations in the format used by chessground.\n *\n * Includes both possible representations of castling moves (unless\n * `chess960` mode is enabled), so that the `rookCastles` option will work\n * correctly.\n */\nconst chessgroundDests = (pos, opts) => {\n    const result = new Map();\n    const ctx = pos.ctx();\n    for (const [from, squares] of pos.allDests(ctx)) {\n        if (squares.nonEmpty()) {\n            const d = Array.from(squares, _util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare);\n            if (!(opts === null || opts === void 0 ? void 0 : opts.chess960) && from === ctx.king && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.squareFile)(from) === 4) {\n                // Chessground needs both types of castling dests and filters based on\n                // a rookCastles setting.\n                if (squares.has(0))\n                    d.push('c1');\n                else if (squares.has(56))\n                    d.push('c8');\n                if (squares.has(7))\n                    d.push('g1');\n                else if (squares.has(63))\n                    d.push('g8');\n            }\n            result.set((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare)(from), d);\n        }\n    }\n    return result;\n};\nconst chessgroundMove = (move) => (0,_types_js__WEBPACK_IMPORTED_MODULE_1__.isDrop)(move) ? [(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare)(move.to)] : [(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare)(move.from), (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare)(move.to)];\nconst scalachessCharPair = (move) => (0,_types_js__WEBPACK_IMPORTED_MODULE_1__.isDrop)(move)\n    ? String.fromCharCode(35 + move.to, 35 + 64 + 8 * 5 + ['queen', 'rook', 'bishop', 'knight', 'pawn'].indexOf(move.role))\n    : String.fromCharCode(35 + move.from, move.promotion\n        ? 35 + 64 + 8 * ['queen', 'rook', 'bishop', 'knight', 'king'].indexOf(move.promotion) + (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.squareFile)(move.to)\n        : 35 + move.to);\nconst lichessRules = (variant) => {\n    switch (variant) {\n        case 'standard':\n        case 'chess960':\n        case 'fromPosition':\n            return 'chess';\n        case 'threeCheck':\n            return '3check';\n        case 'kingOfTheHill':\n            return 'kingofthehill';\n        case 'racingKings':\n            return 'racingkings';\n        default:\n            return variant;\n    }\n};\nconst lichessVariant = (rules) => {\n    switch (rules) {\n        case 'chess':\n            return 'standard';\n        case '3check':\n            return 'threeCheck';\n        case 'kingofthehill':\n            return 'kingOfTheHill';\n        case 'racingkings':\n            return 'racingKings';\n        default:\n            return rules;\n    }\n};\n//# sourceMappingURL=compat.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/compat.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/fen.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/fen.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_BOARD_FEN\": () => (/* binding */ EMPTY_BOARD_FEN),\n/* harmony export */   \"EMPTY_EPD\": () => (/* binding */ EMPTY_EPD),\n/* harmony export */   \"EMPTY_FEN\": () => (/* binding */ EMPTY_FEN),\n/* harmony export */   \"FenError\": () => (/* binding */ FenError),\n/* harmony export */   \"INITIAL_BOARD_FEN\": () => (/* binding */ INITIAL_BOARD_FEN),\n/* harmony export */   \"INITIAL_EPD\": () => (/* binding */ INITIAL_EPD),\n/* harmony export */   \"INITIAL_FEN\": () => (/* binding */ INITIAL_FEN),\n/* harmony export */   \"InvalidFen\": () => (/* binding */ InvalidFen),\n/* harmony export */   \"makeBoardFen\": () => (/* binding */ makeBoardFen),\n/* harmony export */   \"makeCastlingFen\": () => (/* binding */ makeCastlingFen),\n/* harmony export */   \"makeFen\": () => (/* binding */ makeFen),\n/* harmony export */   \"makePiece\": () => (/* binding */ makePiece),\n/* harmony export */   \"makePocket\": () => (/* binding */ makePocket),\n/* harmony export */   \"makePockets\": () => (/* binding */ makePockets),\n/* harmony export */   \"makeRemainingChecks\": () => (/* binding */ makeRemainingChecks),\n/* harmony export */   \"parseBoardFen\": () => (/* binding */ parseBoardFen),\n/* harmony export */   \"parseCastlingFen\": () => (/* binding */ parseCastlingFen),\n/* harmony export */   \"parseFen\": () => (/* binding */ parseFen),\n/* harmony export */   \"parsePiece\": () => (/* binding */ parsePiece),\n/* harmony export */   \"parsePockets\": () => (/* binding */ parsePockets),\n/* harmony export */   \"parseRemainingChecks\": () => (/* binding */ parseRemainingChecks)\n/* harmony export */ });\n/* harmony import */ var _badrap_result__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @badrap/result */ \"./node_modules/.pnpm/@badrap+result@0.2.13/node_modules/@badrap/result/dist/index.modern.mjs\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js\");\n/* harmony import */ var _squareSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./squareSet.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/board.js\");\n/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./setup.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/setup.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n\n\n\n\n\n\nconst INITIAL_BOARD_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nconst INITIAL_EPD = INITIAL_BOARD_FEN + ' w KQkq -';\nconst INITIAL_FEN = INITIAL_EPD + ' 0 1';\nconst EMPTY_BOARD_FEN = '8/8/8/8/8/8/8/8';\nconst EMPTY_EPD = EMPTY_BOARD_FEN + ' w - -';\nconst EMPTY_FEN = EMPTY_EPD + ' 0 1';\nvar InvalidFen;\n(function (InvalidFen) {\n    InvalidFen[\"Fen\"] = \"ERR_FEN\";\n    InvalidFen[\"Board\"] = \"ERR_BOARD\";\n    InvalidFen[\"Pockets\"] = \"ERR_POCKETS\";\n    InvalidFen[\"Turn\"] = \"ERR_TURN\";\n    InvalidFen[\"Castling\"] = \"ERR_CASTLING\";\n    InvalidFen[\"EpSquare\"] = \"ERR_EP_SQUARE\";\n    InvalidFen[\"RemainingChecks\"] = \"ERR_REMAINING_CHECKS\";\n    InvalidFen[\"Halfmoves\"] = \"ERR_HALFMOVES\";\n    InvalidFen[\"Fullmoves\"] = \"ERR_FULLMOVES\";\n})(InvalidFen || (InvalidFen = {}));\nclass FenError extends Error {\n}\nconst nthIndexOf = (haystack, needle, n) => {\n    let index = haystack.indexOf(needle);\n    while (n-- > 0) {\n        if (index === -1)\n            break;\n        index = haystack.indexOf(needle, index + needle.length);\n    }\n    return index;\n};\nconst parseSmallUint = (str) => (/^\\d{1,4}$/.test(str) ? parseInt(str, 10) : undefined);\nconst charToPiece = (ch) => {\n    const role = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.charToRole)(ch);\n    return role && { role, color: ch.toLowerCase() === ch ? 'black' : 'white' };\n};\nconst parseBoardFen = (boardPart) => {\n    const board = _board_js__WEBPACK_IMPORTED_MODULE_1__.Board.empty();\n    let rank = 7;\n    let file = 0;\n    for (let i = 0; i < boardPart.length; i++) {\n        const c = boardPart[i];\n        if (c === '/' && file === 8) {\n            file = 0;\n            rank--;\n        }\n        else {\n            const step = parseInt(c, 10);\n            if (step > 0)\n                file += step;\n            else {\n                if (file >= 8 || rank < 0)\n                    return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Board));\n                const square = file + rank * 8;\n                const piece = charToPiece(c);\n                if (!piece)\n                    return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Board));\n                if (boardPart[i + 1] === '~') {\n                    piece.promoted = true;\n                    i++;\n                }\n                board.set(square, piece);\n                file++;\n            }\n        }\n    }\n    if (rank !== 0 || file !== 8)\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Board));\n    return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(board);\n};\nconst parsePockets = (pocketPart) => {\n    if (pocketPart.length > 64)\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Pockets));\n    const pockets = _setup_js__WEBPACK_IMPORTED_MODULE_3__.Material.empty();\n    for (const c of pocketPart) {\n        const piece = charToPiece(c);\n        if (!piece)\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Pockets));\n        pockets[piece.color][piece.role]++;\n    }\n    return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(pockets);\n};\nconst parseCastlingFen = (board, castlingPart) => {\n    let unmovedRooks = _squareSet_js__WEBPACK_IMPORTED_MODULE_4__.SquareSet.empty();\n    if (castlingPart === '-')\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(unmovedRooks);\n    for (const c of castlingPart) {\n        const lower = c.toLowerCase();\n        const color = c === lower ? 'black' : 'white';\n        const backrank = _squareSet_js__WEBPACK_IMPORTED_MODULE_4__.SquareSet.backrank(color).intersect(board[color]);\n        let candidates;\n        if (lower === 'q')\n            candidates = backrank;\n        else if (lower === 'k')\n            candidates = backrank.reversed();\n        else if ('a' <= lower && lower <= 'h')\n            candidates = _squareSet_js__WEBPACK_IMPORTED_MODULE_4__.SquareSet.fromFile(lower.charCodeAt(0) - 'a'.charCodeAt(0)).intersect(backrank);\n        else\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Castling));\n        for (const square of candidates) {\n            if (board.king.has(square))\n                break;\n            if (board.rook.has(square)) {\n                unmovedRooks = unmovedRooks.with(square);\n                break;\n            }\n        }\n    }\n    if (_types_js__WEBPACK_IMPORTED_MODULE_5__.COLORS.some(color => _squareSet_js__WEBPACK_IMPORTED_MODULE_4__.SquareSet.backrank(color).intersect(unmovedRooks).size() > 2))\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Castling));\n    return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(unmovedRooks);\n};\nconst parseRemainingChecks = (part) => {\n    const parts = part.split('+');\n    if (parts.length === 3 && parts[0] === '') {\n        const white = parseSmallUint(parts[1]);\n        const black = parseSmallUint(parts[2]);\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(white) || white > 3 || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(black) || black > 3)\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.RemainingChecks));\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(new _setup_js__WEBPACK_IMPORTED_MODULE_3__.RemainingChecks(3 - white, 3 - black));\n    }\n    else if (parts.length === 2) {\n        const white = parseSmallUint(parts[0]);\n        const black = parseSmallUint(parts[1]);\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(white) || white > 3 || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(black) || black > 3)\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.RemainingChecks));\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(new _setup_js__WEBPACK_IMPORTED_MODULE_3__.RemainingChecks(white, black));\n    }\n    else\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.RemainingChecks));\n};\nconst parseFen = (fen) => {\n    const parts = fen.split(/[\\s_]+/);\n    const boardPart = parts.shift();\n    // Board and pockets\n    let board;\n    let pockets = _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(undefined);\n    if (boardPart.endsWith(']')) {\n        const pocketStart = boardPart.indexOf('[');\n        if (pocketStart === -1)\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Fen));\n        board = parseBoardFen(boardPart.slice(0, pocketStart));\n        pockets = parsePockets(boardPart.slice(pocketStart + 1, -1));\n    }\n    else {\n        const pocketStart = nthIndexOf(boardPart, '/', 7);\n        if (pocketStart === -1)\n            board = parseBoardFen(boardPart);\n        else {\n            board = parseBoardFen(boardPart.slice(0, pocketStart));\n            pockets = parsePockets(boardPart.slice(pocketStart + 1));\n        }\n    }\n    // Turn\n    let turn;\n    const turnPart = parts.shift();\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(turnPart) || turnPart === 'w')\n        turn = 'white';\n    else if (turnPart === 'b')\n        turn = 'black';\n    else\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Turn));\n    return board.chain(board => {\n        // Castling\n        const castlingPart = parts.shift();\n        const unmovedRooks = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(castlingPart) ? parseCastlingFen(board, castlingPart) : _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(_squareSet_js__WEBPACK_IMPORTED_MODULE_4__.SquareSet.empty());\n        // En passant square\n        const epPart = parts.shift();\n        let epSquare;\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(epPart) && epPart !== '-') {\n            epSquare = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseSquare)(epPart);\n            if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(epSquare))\n                return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.EpSquare));\n        }\n        // Halfmoves or remaining checks\n        let halfmovePart = parts.shift();\n        let earlyRemainingChecks;\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(halfmovePart) && halfmovePart.includes('+')) {\n            earlyRemainingChecks = parseRemainingChecks(halfmovePart);\n            halfmovePart = parts.shift();\n        }\n        const halfmoves = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(halfmovePart) ? parseSmallUint(halfmovePart) : 0;\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(halfmoves))\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Halfmoves));\n        const fullmovesPart = parts.shift();\n        const fullmoves = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(fullmovesPart) ? parseSmallUint(fullmovesPart) : 1;\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(fullmoves))\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Fullmoves));\n        const remainingChecksPart = parts.shift();\n        let remainingChecks = _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(undefined);\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(remainingChecksPart)) {\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(earlyRemainingChecks))\n                return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.RemainingChecks));\n            remainingChecks = parseRemainingChecks(remainingChecksPart);\n        }\n        else if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(earlyRemainingChecks)) {\n            remainingChecks = earlyRemainingChecks;\n        }\n        if (parts.length > 0)\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new FenError(InvalidFen.Fen));\n        return pockets.chain(pockets => unmovedRooks.chain(unmovedRooks => remainingChecks.map(remainingChecks => {\n            return {\n                board,\n                pockets,\n                turn,\n                unmovedRooks,\n                remainingChecks,\n                epSquare,\n                halfmoves,\n                fullmoves: Math.max(1, fullmoves),\n            };\n        })));\n    });\n};\nconst parsePiece = (str) => {\n    if (!str)\n        return;\n    const piece = charToPiece(str[0]);\n    if (!piece)\n        return;\n    if (str.length === 2 && str[1] === '~')\n        piece.promoted = true;\n    else if (str.length > 1)\n        return;\n    return piece;\n};\nconst makePiece = (piece) => {\n    let r = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.roleToChar)(piece.role);\n    if (piece.color === 'white')\n        r = r.toUpperCase();\n    if (piece.promoted)\n        r += '~';\n    return r;\n};\nconst makeBoardFen = (board) => {\n    let fen = '';\n    let empty = 0;\n    for (let rank = 7; rank >= 0; rank--) {\n        for (let file = 0; file < 8; file++) {\n            const square = file + rank * 8;\n            const piece = board.get(square);\n            if (!piece)\n                empty++;\n            else {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                fen += makePiece(piece);\n            }\n            if (file === 7) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                if (rank !== 0)\n                    fen += '/';\n            }\n        }\n    }\n    return fen;\n};\nconst makePocket = (material) => _types_js__WEBPACK_IMPORTED_MODULE_5__.ROLES.map(role => (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.roleToChar)(role).repeat(material[role])).join('');\nconst makePockets = (pocket) => makePocket(pocket.white).toUpperCase() + makePocket(pocket.black);\nconst makeCastlingFen = (board, unmovedRooks) => {\n    let fen = '';\n    for (const color of _types_js__WEBPACK_IMPORTED_MODULE_5__.COLORS) {\n        const backrank = _squareSet_js__WEBPACK_IMPORTED_MODULE_4__.SquareSet.backrank(color);\n        let king = board.kingOf(color);\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(king) && !backrank.has(king))\n            king = undefined;\n        const candidates = board.pieces(color, 'rook').intersect(backrank);\n        for (const rook of unmovedRooks.intersect(candidates).reversed()) {\n            if (rook === candidates.first() && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(king) && rook < king) {\n                fen += color === 'white' ? 'Q' : 'q';\n            }\n            else if (rook === candidates.last() && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(king) && king < rook) {\n                fen += color === 'white' ? 'K' : 'k';\n            }\n            else {\n                const file = _types_js__WEBPACK_IMPORTED_MODULE_5__.FILE_NAMES[(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.squareFile)(rook)];\n                fen += color === 'white' ? file.toUpperCase() : file;\n            }\n        }\n    }\n    return fen || '-';\n};\nconst makeRemainingChecks = (checks) => `${checks.white}+${checks.black}`;\nconst makeFen = (setup, opts) => [\n    makeBoardFen(setup.board) + (setup.pockets ? `[${makePockets(setup.pockets)}]` : ''),\n    setup.turn[0],\n    makeCastlingFen(setup.board, setup.unmovedRooks),\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(setup.epSquare) ? (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare)(setup.epSquare) : '-',\n    ...(setup.remainingChecks ? [makeRemainingChecks(setup.remainingChecks)] : []),\n    ...((opts === null || opts === void 0 ? void 0 : opts.epd) ? [] : [Math.max(0, Math.min(setup.halfmoves, 9999)), Math.max(1, Math.min(setup.fullmoves, 9999))]),\n].join(' ');\n//# sourceMappingURL=fen.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/fen.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/pgn.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/pgn.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Box\": () => (/* binding */ Box),\n/* harmony export */   \"ChildNode\": () => (/* binding */ ChildNode),\n/* harmony export */   \"Node\": () => (/* binding */ Node),\n/* harmony export */   \"PgnError\": () => (/* binding */ PgnError),\n/* harmony export */   \"PgnParser\": () => (/* binding */ PgnParser),\n/* harmony export */   \"defaultGame\": () => (/* binding */ defaultGame),\n/* harmony export */   \"defaultHeaders\": () => (/* binding */ defaultHeaders),\n/* harmony export */   \"emptyHeaders\": () => (/* binding */ emptyHeaders),\n/* harmony export */   \"isChildNode\": () => (/* binding */ isChildNode),\n/* harmony export */   \"isMate\": () => (/* binding */ isMate),\n/* harmony export */   \"isPawns\": () => (/* binding */ isPawns),\n/* harmony export */   \"makeComment\": () => (/* binding */ makeComment),\n/* harmony export */   \"makeOutcome\": () => (/* binding */ makeOutcome),\n/* harmony export */   \"makePgn\": () => (/* binding */ makePgn),\n/* harmony export */   \"makeVariant\": () => (/* binding */ makeVariant),\n/* harmony export */   \"parseComment\": () => (/* binding */ parseComment),\n/* harmony export */   \"parseOutcome\": () => (/* binding */ parseOutcome),\n/* harmony export */   \"parsePgn\": () => (/* binding */ parsePgn),\n/* harmony export */   \"parseVariant\": () => (/* binding */ parseVariant),\n/* harmony export */   \"setStartingPosition\": () => (/* binding */ setStartingPosition),\n/* harmony export */   \"startingPosition\": () => (/* binding */ startingPosition),\n/* harmony export */   \"transform\": () => (/* binding */ transform),\n/* harmony export */   \"walk\": () => (/* binding */ walk)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n/* harmony import */ var _fen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fen.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/fen.js\");\n/* harmony import */ var _chess_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chess.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/chess.js\");\n/* harmony import */ var _variant_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./variant.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/variant.js\");\n/* harmony import */ var _badrap_result__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @badrap/result */ \"./node_modules/.pnpm/@badrap+result@0.2.13/node_modules/@badrap/result/dist/index.modern.mjs\");\n/**\n * Parse, transform and write PGN.\n *\n * ## Parser\n *\n * The parser will interpret any input as a PGN, creating a tree of\n * syntactically valid (but not necessarily legal) moves, skipping any invalid\n * tokens.\n *\n * ```ts\n * import { parsePgn, startingPosition } from 'chessops/pgn';\n * import { parseSan } from 'chessops/san';\n *\n * const pgn = '1. d4 d5 *';\n * const games = parsePgn(pgn);\n * for (const game of games) {\n *   const pos = startingPosition(game.headers).unwrap();\n *   for (const node of game.moves.mainline()) {\n *     const move = parseSan(pos, node.san);\n *     if (!move) break; // Illegal move\n *     pos.play(move);\n *   }\n * }\n * ```\n *\n * ## Streaming parser\n *\n * The module also provides a denial-of-service resistant streaming parser.\n * It can be configured with a budget for reasonable complexity of a single\n * game, fed with chunks of text, and will yield parsed games as they are\n * completed.\n *\n * ```ts\n *\n * import { createReadStream } from 'fs';\n * import { PgnParser } from 'chessops/pgn';\n *\n * const stream = createReadStream('games.pgn', { encoding: 'utf-8' });\n *\n * const parser = new PgnParser((game, err) => {\n *   if (err) {\n *     // Budget exceeded.\n *     stream.destroy(err);\n *   }\n *\n *   // Use game ...\n * });\n *\n * await new Promise<void>(resolve =>\n *   stream\n *     .on('data', (chunk: string) => parser.parse(chunk, { stream: true }))\n *     .on('close', () => {\n *       parser.parse('');\n *       resolve();\n *     })\n * );\n * ```\n *\n * ## Augmenting the game tree\n *\n * You can use `walk` to visit all nodes in the game tree, or `transform`\n * to augment it with user data.\n *\n * Both allow you to provide context. You update the context inside the\n * callback, and it is automatically `clone()`-ed at each fork.\n * In the example below, the current position `pos` is provided as context.\n *\n * ```ts\n * import { transform } from 'chessops/pgn';\n * import { makeFen } from 'chessops/fen';\n * import { parseSan, makeSanAndPlay } from 'chessops/san';\n *\n * const pos = startingPosition(game.headers).unwrap();\n * game.moves = transform(game.moves, pos, (pos, node) => {\n *   const move = parseSan(pos, node.san);\n *   if (!move) {\n *     // Illegal move. Returning undefined cuts of the tree here.\n *     return;\n *   }\n *\n *   const san = makeSanAndPlay(pos, move); // Mutating pos!\n *\n *   return {\n *     ...node, // Keep comments and annotation glyphs\n *     san, // Normalized SAN\n *     fen: makeFen(pos.toSetup()), // Add arbitrary user data to node\n *   };\n * });\n * ```\n *\n * ## Writing\n *\n * Requires each node to at least have a `san` property.\n *\n * ```\n * import { makePgn } from 'chessops/pgn';\n *\n * const rewrittenPgn = makePgn(game);\n * ```\n *\n * @packageDocumentation\n */\n\n\n\n\n\nconst defaultGame = (initHeaders = defaultHeaders) => ({\n    headers: initHeaders(),\n    moves: new Node(),\n});\nclass Node {\n    constructor() {\n        this.children = [];\n    }\n    *mainline() {\n        let node = this;\n        while (node.children.length) {\n            const child = node.children[0];\n            yield child.data;\n            node = child;\n        }\n    }\n}\nclass ChildNode extends Node {\n    constructor(data) {\n        super();\n        this.data = data;\n    }\n}\nconst isChildNode = (node) => node instanceof (ChildNode);\nclass Box {\n    constructor(value) {\n        this.value = value;\n    }\n    clone() {\n        return new Box(this.value);\n    }\n}\nconst transform = (node, ctx, f) => {\n    const root = new Node();\n    const stack = [\n        {\n            before: node,\n            after: root,\n            ctx,\n        },\n    ];\n    let frame;\n    while ((frame = stack.pop())) {\n        for (let childIndex = 0; childIndex < frame.before.children.length; childIndex++) {\n            const ctx = childIndex < frame.before.children.length - 1 ? frame.ctx.clone() : frame.ctx;\n            const childBefore = frame.before.children[childIndex];\n            const data = f(ctx, childBefore.data, childIndex);\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(data)) {\n                const childAfter = new ChildNode(data);\n                frame.after.children.push(childAfter);\n                stack.push({\n                    before: childBefore,\n                    after: childAfter,\n                    ctx,\n                });\n            }\n        }\n    }\n    return root;\n};\nconst walk = (node, ctx, f) => {\n    const stack = [{ node, ctx }];\n    let frame;\n    while ((frame = stack.pop())) {\n        for (let childIndex = 0; childIndex < frame.node.children.length; childIndex++) {\n            const ctx = childIndex < frame.node.children.length - 1 ? frame.ctx.clone() : frame.ctx;\n            const child = frame.node.children[childIndex];\n            if (f(ctx, child.data, childIndex) !== false)\n                stack.push({ node: child, ctx });\n        }\n    }\n};\nconst makeOutcome = (outcome) => {\n    if (!outcome)\n        return '*';\n    else if (outcome.winner === 'white')\n        return '1-0';\n    else if (outcome.winner === 'black')\n        return '0-1';\n    else\n        return '1/2-1/2';\n};\nconst parseOutcome = (s) => {\n    if (s === '1-0')\n        return { winner: 'white' };\n    else if (s === '0-1')\n        return { winner: 'black' };\n    else if (s === '1/2-1/2')\n        return { winner: undefined };\n    else\n        return;\n};\nconst escapeHeader = (value) => value.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\nconst safeComment = (comment) => comment.replace(/\\}/g, '');\nconst makePgn = (game) => {\n    const builder = [], tokens = [];\n    if (game.headers.size) {\n        for (const [key, value] of game.headers.entries()) {\n            builder.push('[', key, ' \"', escapeHeader(value), '\"]\\n');\n        }\n        builder.push('\\n');\n    }\n    for (const comment of game.comments || [])\n        tokens.push('{', safeComment(comment), '}');\n    const fen = game.headers.get('FEN');\n    const initialPly = fen\n        ? (0,_fen_js__WEBPACK_IMPORTED_MODULE_1__.parseFen)(fen).unwrap(setup => (setup.fullmoves - 1) * 2 + (setup.turn === 'white' ? 0 : 1), _ => 0)\n        : 0;\n    const stack = [];\n    if (game.moves.children.length) {\n        const variations = game.moves.children[Symbol.iterator]();\n        stack.push({\n            state: 0 /* MakePgnState.Pre */,\n            ply: initialPly,\n            node: variations.next().value,\n            sidelines: variations,\n            startsVariation: false,\n            inVariation: false,\n        });\n    }\n    let forceMoveNumber = true;\n    while (stack.length) {\n        const frame = stack[stack.length - 1];\n        if (frame.inVariation) {\n            tokens.push(')');\n            frame.inVariation = false;\n            forceMoveNumber = true;\n        }\n        switch (frame.state) {\n            case 0 /* MakePgnState.Pre */:\n                for (const comment of frame.node.data.startingComments || []) {\n                    tokens.push('{', safeComment(comment), '}');\n                    forceMoveNumber = true;\n                }\n                if (forceMoveNumber || frame.ply % 2 === 0) {\n                    tokens.push(Math.floor(frame.ply / 2) + 1 + (frame.ply % 2 ? '...' : '.'));\n                    forceMoveNumber = false;\n                }\n                tokens.push(frame.node.data.san);\n                for (const nag of frame.node.data.nags || []) {\n                    tokens.push('$' + nag);\n                    forceMoveNumber = true;\n                }\n                for (const comment of frame.node.data.comments || []) {\n                    tokens.push('{', safeComment(comment), '}');\n                }\n                frame.state = 1 /* MakePgnState.Sidelines */; // fall through\n            case 1 /* MakePgnState.Sidelines */: {\n                const child = frame.sidelines.next();\n                if (child.done) {\n                    if (frame.node.children.length) {\n                        const variations = frame.node.children[Symbol.iterator]();\n                        stack.push({\n                            state: 0 /* MakePgnState.Pre */,\n                            ply: frame.ply + 1,\n                            node: variations.next().value,\n                            sidelines: variations,\n                            startsVariation: false,\n                            inVariation: false,\n                        });\n                    }\n                    frame.state = 2 /* MakePgnState.End */;\n                }\n                else {\n                    tokens.push('(');\n                    forceMoveNumber = true;\n                    stack.push({\n                        state: 0 /* MakePgnState.Pre */,\n                        ply: frame.ply,\n                        node: child.value,\n                        sidelines: [][Symbol.iterator](),\n                        startsVariation: true,\n                        inVariation: false,\n                    });\n                    frame.inVariation = true;\n                }\n                break;\n            }\n            case 2 /* MakePgnState.End */:\n                stack.pop();\n        }\n    }\n    tokens.push(makeOutcome(parseOutcome(game.headers.get('Result'))));\n    builder.push(tokens.join(' '), '\\n');\n    return builder.join('');\n};\nconst defaultHeaders = () => new Map([\n    ['Event', '?'],\n    ['Site', '?'],\n    ['Date', '????.??.??'],\n    ['Round', '?'],\n    ['White', '?'],\n    ['Black', '?'],\n    ['Result', '*'],\n]);\nconst emptyHeaders = () => new Map();\nconst BOM = '\\ufeff';\nconst isWhitespace = (line) => /^\\s*$/.test(line);\nconst isCommentLine = (line) => line.startsWith('%');\nclass PgnError extends Error {\n}\nclass PgnParser {\n    constructor(emitGame, initHeaders = defaultHeaders, maxBudget = 1000000) {\n        this.emitGame = emitGame;\n        this.initHeaders = initHeaders;\n        this.maxBudget = maxBudget;\n        this.lineBuf = [];\n        this.resetGame();\n        this.state = 0 /* ParserState.Bom */;\n    }\n    resetGame() {\n        this.budget = this.maxBudget;\n        this.found = false;\n        this.state = 1 /* ParserState.Pre */;\n        this.game = defaultGame(this.initHeaders);\n        this.stack = [{ parent: this.game.moves, root: true }];\n        this.commentBuf = [];\n    }\n    consumeBudget(cost) {\n        this.budget -= cost;\n        if (this.budget < 0)\n            throw new PgnError('ERR_PGN_BUDGET');\n    }\n    parse(data, options) {\n        if (this.budget < 0)\n            return;\n        try {\n            let idx = 0;\n            for (;;) {\n                const nlIdx = data.indexOf('\\n', idx);\n                if (nlIdx === -1) {\n                    break;\n                }\n                const crIdx = nlIdx > idx && data[nlIdx - 1] === '\\r' ? nlIdx - 1 : nlIdx;\n                this.consumeBudget(nlIdx - idx);\n                this.lineBuf.push(data.slice(idx, crIdx));\n                idx = nlIdx + 1;\n                this.handleLine();\n            }\n            this.consumeBudget(data.length - idx);\n            this.lineBuf.push(data.slice(idx));\n            if (!(options === null || options === void 0 ? void 0 : options.stream)) {\n                this.handleLine();\n                this.emit(undefined);\n            }\n        }\n        catch (err) {\n            this.emit(err);\n        }\n    }\n    handleLine() {\n        let freshLine = true;\n        let line = this.lineBuf.join('');\n        this.lineBuf = [];\n        continuedLine: for (;;) {\n            switch (this.state) {\n                case 0 /* ParserState.Bom */:\n                    if (line.startsWith(BOM))\n                        line = line.slice(BOM.length);\n                    this.state = 1 /* ParserState.Pre */; // fall through\n                case 1 /* ParserState.Pre */:\n                    if (isWhitespace(line) || isCommentLine(line))\n                        return;\n                    this.found = true;\n                    this.state = 2 /* ParserState.Headers */; // fall through\n                case 2 /* ParserState.Headers */: {\n                    if (isCommentLine(line))\n                        return;\n                    let moreHeaders = true;\n                    while (moreHeaders) {\n                        moreHeaders = false;\n                        line = line.replace(/^\\s*\\[([A-Za-z0-9][A-Za-z0-9_+#=:-]*)\\s+\"((?:[^\"\\\\]|\\\\\"|\\\\\\\\)*)\"\\]/, (_match, headerName, headerValue) => {\n                            this.consumeBudget(200);\n                            this.game.headers.set(headerName, headerValue.replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\'));\n                            moreHeaders = true;\n                            freshLine = false;\n                            return '';\n                        });\n                    }\n                    if (isWhitespace(line))\n                        return;\n                    this.state = 3 /* ParserState.Moves */; // fall through\n                }\n                case 3 /* ParserState.Moves */: {\n                    if (freshLine) {\n                        if (isCommentLine(line))\n                            return;\n                        if (isWhitespace(line))\n                            return this.emit(undefined);\n                    }\n                    const tokenRegex = /(?:[NBKRQ]?[a-h]?[1-8]?[-x]?[a-h][1-8](?:=?[nbrqkNBRQK])?|[pnbrqkPNBRQK]?@[a-h][1-8]|O-O-O|0-0-0|O-O|0-0)[+#]?|--|Z0|0000|@@@@|{|;|\\$\\d{1,4}|[?!]{1,2}|\\(|\\)|\\*|1-0|0-1|1\\/2-1\\/2/g;\n                    let match;\n                    while ((match = tokenRegex.exec(line))) {\n                        const frame = this.stack[this.stack.length - 1];\n                        let token = match[0];\n                        if (token === ';')\n                            return;\n                        else if (token.startsWith('$'))\n                            this.handleNag(parseInt(token.slice(1), 10));\n                        else if (token === '!')\n                            this.handleNag(1);\n                        else if (token === '?')\n                            this.handleNag(2);\n                        else if (token === '!!')\n                            this.handleNag(3);\n                        else if (token === '??')\n                            this.handleNag(4);\n                        else if (token === '!?')\n                            this.handleNag(5);\n                        else if (token === '?!')\n                            this.handleNag(6);\n                        else if (token === '1-0' || token === '0-1' || token === '1/2-1/2' || token === '*') {\n                            if (this.stack.length === 1 && token !== '*')\n                                this.game.headers.set('Result', token);\n                        }\n                        else if (token === '(') {\n                            this.consumeBudget(100);\n                            this.stack.push({ parent: frame.parent, root: false });\n                        }\n                        else if (token === ')') {\n                            if (this.stack.length > 1)\n                                this.stack.pop();\n                        }\n                        else if (token === '{') {\n                            const openIndex = tokenRegex.lastIndex;\n                            const beginIndex = line[openIndex] === ' ' ? openIndex + 1 : openIndex;\n                            line = line.slice(beginIndex);\n                            this.state = 4 /* ParserState.Comment */;\n                            continue continuedLine;\n                        }\n                        else {\n                            this.consumeBudget(100);\n                            if (token === 'Z0' || token === '0000' || token === '@@@@')\n                                token = '--';\n                            else if (token.startsWith('0'))\n                                token = token.replace(/0/g, 'O');\n                            if (frame.node)\n                                frame.parent = frame.node;\n                            frame.node = new ChildNode({\n                                san: token,\n                                startingComments: frame.startingComments,\n                            });\n                            frame.startingComments = undefined;\n                            frame.root = false;\n                            frame.parent.children.push(frame.node);\n                        }\n                    }\n                    return;\n                }\n                case 4 /* ParserState.Comment */: {\n                    const closeIndex = line.indexOf('}');\n                    if (closeIndex === -1) {\n                        this.commentBuf.push(line);\n                        return;\n                    }\n                    else {\n                        const endIndex = closeIndex > 0 && line[closeIndex - 1] === ' ' ? closeIndex - 1 : closeIndex;\n                        this.commentBuf.push(line.slice(0, endIndex));\n                        this.handleComment();\n                        line = line.slice(closeIndex);\n                        this.state = 3 /* ParserState.Moves */;\n                        freshLine = false;\n                    }\n                }\n            }\n        }\n    }\n    handleNag(nag) {\n        var _a;\n        this.consumeBudget(50);\n        const frame = this.stack[this.stack.length - 1];\n        if (frame.node) {\n            (_a = frame.node.data).nags || (_a.nags = []);\n            frame.node.data.nags.push(nag);\n        }\n    }\n    handleComment() {\n        var _a, _b;\n        this.consumeBudget(100);\n        const frame = this.stack[this.stack.length - 1];\n        const comment = this.commentBuf.join('\\n');\n        this.commentBuf = [];\n        if (frame.node) {\n            (_a = frame.node.data).comments || (_a.comments = []);\n            frame.node.data.comments.push(comment);\n        }\n        else if (frame.root) {\n            (_b = this.game).comments || (_b.comments = []);\n            this.game.comments.push(comment);\n        }\n        else {\n            frame.startingComments || (frame.startingComments = []);\n            frame.startingComments.push(comment);\n        }\n    }\n    emit(err) {\n        if (this.state === 4 /* ParserState.Comment */)\n            this.handleComment();\n        if (err)\n            return this.emitGame(this.game, err);\n        if (this.found)\n            this.emitGame(this.game, undefined);\n        this.resetGame();\n    }\n}\nconst parsePgn = (pgn, initHeaders = defaultHeaders) => {\n    const games = [];\n    new PgnParser(game => games.push(game), initHeaders, NaN).parse(pgn);\n    return games;\n};\nconst parseVariant = (variant) => {\n    switch ((variant || 'chess').toLowerCase()) {\n        case 'chess':\n        case 'chess960':\n        case 'chess 960':\n        case 'standard':\n        case 'from position':\n        case 'classical':\n        case 'normal':\n        case 'fischerandom': // Cute Chess\n        case 'fischerrandom':\n        case 'fischer random':\n        case 'wild/0':\n        case 'wild/1':\n        case 'wild/2':\n        case 'wild/3':\n        case 'wild/4':\n        case 'wild/5':\n        case 'wild/6':\n        case 'wild/7':\n        case 'wild/8':\n        case 'wild/8a':\n            return 'chess';\n        case 'crazyhouse':\n        case 'crazy house':\n        case 'house':\n        case 'zh':\n            return 'crazyhouse';\n        case 'king of the hill':\n        case 'koth':\n        case 'kingofthehill':\n            return 'kingofthehill';\n        case 'three-check':\n        case 'three check':\n        case 'threecheck':\n        case 'three check chess':\n        case '3-check':\n        case '3 check':\n        case '3check':\n            return '3check';\n        case 'antichess':\n        case 'anti chess':\n        case 'anti':\n            return 'antichess';\n        case 'atomic':\n        case 'atom':\n        case 'atomic chess':\n            return 'atomic';\n        case 'horde':\n        case 'horde chess':\n            return 'horde';\n        case 'racing kings':\n        case 'racingkings':\n        case 'racing':\n        case 'race':\n            return 'racingkings';\n        default:\n            return;\n    }\n};\nconst makeVariant = (rules) => {\n    switch (rules) {\n        case 'chess':\n            return;\n        case 'crazyhouse':\n            return 'Crazyhouse';\n        case 'racingkings':\n            return 'Racing Kings';\n        case 'horde':\n            return 'Horde';\n        case 'atomic':\n            return 'Atomic';\n        case 'antichess':\n            return 'Antichess';\n        case '3check':\n            return 'Three-check';\n        case 'kingofthehill':\n            return 'King of the Hill';\n    }\n};\nconst startingPosition = (headers, opts) => {\n    const rules = parseVariant(headers.get('Variant'));\n    if (!rules)\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_3__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_3__.IllegalSetup.Variant));\n    const fen = headers.get('FEN');\n    if (fen)\n        return (0,_fen_js__WEBPACK_IMPORTED_MODULE_1__.parseFen)(fen).chain(setup => (0,_variant_js__WEBPACK_IMPORTED_MODULE_4__.setupPosition)(rules, setup, opts));\n    else\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok((0,_variant_js__WEBPACK_IMPORTED_MODULE_4__.defaultPosition)(rules));\n};\nconst setStartingPosition = (headers, pos) => {\n    const variant = makeVariant(pos.rules);\n    if (variant)\n        headers.set('Variant', variant);\n    else\n        headers.delete('Variant');\n    const fen = (0,_fen_js__WEBPACK_IMPORTED_MODULE_1__.makeFen)(pos.toSetup());\n    const defaultFen = (0,_fen_js__WEBPACK_IMPORTED_MODULE_1__.makeFen)((0,_variant_js__WEBPACK_IMPORTED_MODULE_4__.defaultPosition)(pos.rules).toSetup());\n    if (fen !== defaultFen)\n        headers.set('FEN', fen);\n    else\n        headers.delete('FEN');\n};\nconst isPawns = (ev) => 'pawns' in ev;\nconst isMate = (ev) => 'mate' in ev;\nconst makeClk = (seconds) => {\n    seconds = Math.max(0, seconds);\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    seconds = (seconds % 3600) % 60;\n    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toLocaleString('en', {\n        minimumIntegerDigits: 2,\n        maximumFractionDigits: 3,\n    })}`;\n};\nconst makeCommentShapeColor = (color) => {\n    switch (color) {\n        case 'green':\n            return 'G';\n        case 'red':\n            return 'R';\n        case 'yellow':\n            return 'Y';\n        case 'blue':\n            return 'B';\n    }\n};\nfunction parseCommentShapeColor(str) {\n    switch (str) {\n        case 'G':\n            return 'green';\n        case 'R':\n            return 'red';\n        case 'Y':\n            return 'yellow';\n        case 'B':\n            return 'blue';\n        default:\n            return;\n    }\n}\nconst makeCommentShape = (shape) => shape.to === shape.from\n    ? `${makeCommentShapeColor(shape.color)}${(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare)(shape.to)}`\n    : `${makeCommentShapeColor(shape.color)}${(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare)(shape.from)}${(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.makeSquare)(shape.to)}`;\nconst parseCommentShape = (str) => {\n    const color = parseCommentShapeColor(str.slice(0, 1));\n    const from = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseSquare)(str.slice(1, 3));\n    const to = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.parseSquare)(str.slice(3, 5));\n    if (!color || !(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(from))\n        return;\n    if (str.length === 3)\n        return { color, from, to: from };\n    if (str.length === 5 && (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(to))\n        return { color, from, to };\n    return;\n};\nconst makeEval = (ev) => {\n    const str = isMate(ev) ? '#' + ev.mate : ev.pawns.toFixed(2);\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(ev.depth) ? str + ',' + ev.depth : str;\n};\nconst makeComment = (comment) => {\n    const builder = [];\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(comment.text))\n        builder.push(comment.text);\n    const circles = (comment.shapes || []).filter(shape => shape.to === shape.from).map(makeCommentShape);\n    if (circles.length)\n        builder.push(`[%csl ${circles.join(',')}]`);\n    const arrows = (comment.shapes || []).filter(shape => shape.to !== shape.from).map(makeCommentShape);\n    if (arrows.length)\n        builder.push(`[%cal ${arrows.join(',')}]`);\n    if (comment.evaluation)\n        builder.push(`[%eval ${makeEval(comment.evaluation)}]`);\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(comment.emt))\n        builder.push(`[%emt ${makeClk(comment.emt)}]`);\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.defined)(comment.clock))\n        builder.push(`[%clk ${makeClk(comment.clock)}]`);\n    return builder.join(' ');\n};\nconst parseComment = (comment) => {\n    let emt, clock, evaluation;\n    const shapes = [];\n    const text = comment\n        .replace(/\\s?\\[%(emt|clk)\\s(\\d{1,5}):(\\d{1,2}):(\\d{1,2}(?:\\.\\d{0,3})?)\\]\\s?/g, (_, annotation, hours, minutes, seconds) => {\n        const value = parseInt(hours, 10) * 3600 + parseInt(minutes, 10) * 60 + parseFloat(seconds);\n        if (annotation === 'emt')\n            emt = value;\n        else if (annotation === 'clk')\n            clock = value;\n        return '  ';\n    })\n        .replace(/\\s?\\[%(?:csl|cal)\\s([RGYB][a-h][1-8](?:[a-h][1-8])?(?:,[RGYB][a-h][1-8](?:[a-h][1-8])?)*)\\]\\s?/g, (_, arrows) => {\n        for (const arrow of arrows.split(',')) {\n            shapes.push(parseCommentShape(arrow));\n        }\n        return '  ';\n    })\n        .replace(/\\s?\\[%eval\\s(?:#([+-]?\\d{1,5})|([+-]?(?:\\d{1,5}|\\d{0,5}\\.\\d{1,2})))(?:,(\\d{1,5}))?\\]\\s?/g, (_, mate, pawns, d) => {\n        const depth = d && parseInt(d, 10);\n        evaluation = mate ? { mate: parseInt(mate, 10), depth } : { pawns: parseFloat(pawns), depth };\n        return '  ';\n    })\n        .trim();\n    return {\n        text,\n        shapes,\n        emt,\n        clock,\n        evaluation,\n    };\n};\n//# sourceMappingURL=pgn.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/pgn.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/san.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/san.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeSan\": () => (/* binding */ makeSan),\n/* harmony export */   \"makeSanAndPlay\": () => (/* binding */ makeSanAndPlay),\n/* harmony export */   \"makeSanVariation\": () => (/* binding */ makeSanVariation),\n/* harmony export */   \"parseSan\": () => (/* binding */ parseSan)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n/* harmony import */ var _squareSet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./squareSet.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js\");\n/* harmony import */ var _attacks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attacks.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/attacks.js\");\n\n\n\n\nconst makeSanWithoutSuffix = (pos, move) => {\n    let san = '';\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isDrop)(move)) {\n        if (move.role !== 'pawn')\n            san = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.roleToChar)(move.role).toUpperCase();\n        san += '@' + (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.makeSquare)(move.to);\n    }\n    else {\n        const role = pos.board.getRole(move.from);\n        if (!role)\n            return '--';\n        if (role === 'king' && (pos.board[pos.turn].has(move.to) || Math.abs(move.to - move.from) === 2)) {\n            san = move.to > move.from ? 'O-O' : 'O-O-O';\n        }\n        else {\n            const capture = pos.board.occupied.has(move.to) || (role === 'pawn' && (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(move.from) !== (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(move.to));\n            if (role !== 'pawn') {\n                san = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.roleToChar)(role).toUpperCase();\n                // Disambiguation\n                let others;\n                if (role === 'king')\n                    others = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_2__.kingAttacks)(move.to).intersect(pos.board.king);\n                else if (role === 'queen')\n                    others = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_2__.queenAttacks)(move.to, pos.board.occupied).intersect(pos.board.queen);\n                else if (role === 'rook')\n                    others = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_2__.rookAttacks)(move.to, pos.board.occupied).intersect(pos.board.rook);\n                else if (role === 'bishop')\n                    others = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_2__.bishopAttacks)(move.to, pos.board.occupied).intersect(pos.board.bishop);\n                else\n                    others = (0,_attacks_js__WEBPACK_IMPORTED_MODULE_2__.knightAttacks)(move.to).intersect(pos.board.knight);\n                others = others.intersect(pos.board[pos.turn]).without(move.from);\n                if (others.nonEmpty()) {\n                    const ctx = pos.ctx();\n                    for (const from of others) {\n                        if (!pos.dests(from, ctx).has(move.to))\n                            others = others.without(from);\n                    }\n                    if (others.nonEmpty()) {\n                        let row = false;\n                        let column = others.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.fromRank((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareRank)(move.from)));\n                        if (others.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.fromFile((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(move.from))))\n                            row = true;\n                        else\n                            column = true;\n                        if (column)\n                            san += _types_js__WEBPACK_IMPORTED_MODULE_0__.FILE_NAMES[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(move.from)];\n                        if (row)\n                            san += _types_js__WEBPACK_IMPORTED_MODULE_0__.RANK_NAMES[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareRank)(move.from)];\n                    }\n                }\n            }\n            else if (capture)\n                san = _types_js__WEBPACK_IMPORTED_MODULE_0__.FILE_NAMES[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(move.from)];\n            if (capture)\n                san += 'x';\n            san += (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.makeSquare)(move.to);\n            if (move.promotion)\n                san += '=' + (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.roleToChar)(move.promotion).toUpperCase();\n        }\n    }\n    return san;\n};\nconst makeSanAndPlay = (pos, move) => {\n    var _a;\n    const san = makeSanWithoutSuffix(pos, move);\n    pos.play(move);\n    if ((_a = pos.outcome()) === null || _a === void 0 ? void 0 : _a.winner)\n        return san + '#';\n    if (pos.isCheck())\n        return san + '+';\n    return san;\n};\nconst makeSanVariation = (pos, variation) => {\n    var _a;\n    pos = pos.clone();\n    const line = [];\n    for (let i = 0; i < variation.length; i++) {\n        if (i !== 0)\n            line.push(' ');\n        if (pos.turn === 'white')\n            line.push(pos.fullmoves, '. ');\n        else if (i === 0)\n            line.push(pos.fullmoves, '... ');\n        const san = makeSanWithoutSuffix(pos, variation[i]);\n        pos.play(variation[i]);\n        line.push(san);\n        if (san === '--')\n            return line.join('');\n        if (i === variation.length - 1 && ((_a = pos.outcome()) === null || _a === void 0 ? void 0 : _a.winner))\n            line.push('#');\n        else if (pos.isCheck())\n            line.push('+');\n    }\n    return line.join('');\n};\nconst makeSan = (pos, move) => makeSanAndPlay(pos.clone(), move);\nconst parseSan = (pos, san) => {\n    const ctx = pos.ctx();\n    // Normal move\n    const match = san.match(/^([NBRQK])?([a-h])?([1-8])?[-x]?([a-h][1-8])(?:=?([nbrqkNBRQK]))?[+#]?$/);\n    if (!match) {\n        // Castling\n        let castlingSide;\n        if (san === 'O-O' || san === 'O-O+' || san === 'O-O#')\n            castlingSide = 'h';\n        else if (san === 'O-O-O' || san === 'O-O-O+' || san === 'O-O-O#')\n            castlingSide = 'a';\n        if (castlingSide) {\n            const rook = pos.castles.rook[pos.turn][castlingSide];\n            if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(ctx.king) || !(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(rook) || !pos.dests(ctx.king, ctx).has(rook))\n                return;\n            return {\n                from: ctx.king,\n                to: rook,\n            };\n        }\n        // Drop\n        const match = san.match(/^([pnbrqkPNBRQK])?@([a-h][1-8])[+#]?$/);\n        if (!match)\n            return;\n        const move = {\n            role: match[1] ? (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.charToRole)(match[1]) : 'pawn',\n            to: (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.parseSquare)(match[2]),\n        };\n        return pos.isLegal(move, ctx) ? move : undefined;\n    }\n    const role = match[1] ? (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.charToRole)(match[1]) : 'pawn';\n    const to = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.parseSquare)(match[4]);\n    const promotion = match[5] ? (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.charToRole)(match[5]) : undefined;\n    if (!!promotion !== (role === 'pawn' && _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.backranks().has(to)))\n        return;\n    if (promotion === 'king' && pos.rules !== 'antichess')\n        return;\n    let candidates = pos.board.pieces(pos.turn, role);\n    if (role === 'pawn' && !match[2])\n        candidates = candidates.intersect(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.fromFile((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(to)));\n    else if (match[2])\n        candidates = candidates.intersect(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.fromFile(match[2].charCodeAt(0) - 'a'.charCodeAt(0)));\n    if (match[3])\n        candidates = candidates.intersect(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.fromRank(match[3].charCodeAt(0) - '1'.charCodeAt(0)));\n    // Optimization: Reduce set of candidates\n    const pawnAdvance = role === 'pawn' ? _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.fromFile((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.squareFile)(to)) : _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n    candidates = candidates.intersect(pawnAdvance.union((0,_attacks_js__WEBPACK_IMPORTED_MODULE_2__.attacks)({ color: (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.opposite)(pos.turn), role }, to, pos.board.occupied)));\n    // Check uniqueness and legality\n    let from;\n    for (const candidate of candidates) {\n        if (pos.dests(candidate, ctx).has(to)) {\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(from))\n                return; // Ambiguous\n            from = candidate;\n        }\n    }\n    if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.defined)(from))\n        return; // Illegal\n    return {\n        from,\n        to,\n        promotion,\n    };\n};\n//# sourceMappingURL=san.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/san.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/setup.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/setup.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Material\": () => (/* binding */ Material),\n/* harmony export */   \"MaterialSide\": () => (/* binding */ MaterialSide),\n/* harmony export */   \"RemainingChecks\": () => (/* binding */ RemainingChecks),\n/* harmony export */   \"defaultSetup\": () => (/* binding */ defaultSetup),\n/* harmony export */   \"setupClone\": () => (/* binding */ setupClone),\n/* harmony export */   \"setupEquals\": () => (/* binding */ setupEquals)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js\");\n/* harmony import */ var _squareSet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./squareSet.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/board.js\");\n\n\n\nclass MaterialSide {\n    constructor() { }\n    static empty() {\n        const m = new MaterialSide();\n        for (const role of _types_js__WEBPACK_IMPORTED_MODULE_0__.ROLES)\n            m[role] = 0;\n        return m;\n    }\n    static fromBoard(board, color) {\n        const m = new MaterialSide();\n        for (const role of _types_js__WEBPACK_IMPORTED_MODULE_0__.ROLES)\n            m[role] = board.pieces(color, role).size();\n        return m;\n    }\n    clone() {\n        const m = new MaterialSide();\n        for (const role of _types_js__WEBPACK_IMPORTED_MODULE_0__.ROLES)\n            m[role] = this[role];\n        return m;\n    }\n    equals(other) {\n        return _types_js__WEBPACK_IMPORTED_MODULE_0__.ROLES.every(role => this[role] === other[role]);\n    }\n    add(other) {\n        const m = new MaterialSide();\n        for (const role of _types_js__WEBPACK_IMPORTED_MODULE_0__.ROLES)\n            m[role] = this[role] + other[role];\n        return m;\n    }\n    nonEmpty() {\n        return _types_js__WEBPACK_IMPORTED_MODULE_0__.ROLES.some(role => this[role] > 0);\n    }\n    isEmpty() {\n        return !this.nonEmpty();\n    }\n    hasPawns() {\n        return this.pawn > 0;\n    }\n    hasNonPawns() {\n        return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0;\n    }\n    size() {\n        return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king;\n    }\n}\nclass Material {\n    constructor(white, black) {\n        this.white = white;\n        this.black = black;\n    }\n    static empty() {\n        return new Material(MaterialSide.empty(), MaterialSide.empty());\n    }\n    static fromBoard(board) {\n        return new Material(MaterialSide.fromBoard(board, 'white'), MaterialSide.fromBoard(board, 'black'));\n    }\n    clone() {\n        return new Material(this.white.clone(), this.black.clone());\n    }\n    equals(other) {\n        return this.white.equals(other.white) && this.black.equals(other.black);\n    }\n    add(other) {\n        return new Material(this.white.add(other.white), this.black.add(other.black));\n    }\n    count(role) {\n        return this.white[role] + this.black[role];\n    }\n    size() {\n        return this.white.size() + this.black.size();\n    }\n    isEmpty() {\n        return this.white.isEmpty() && this.black.isEmpty();\n    }\n    nonEmpty() {\n        return !this.isEmpty();\n    }\n    hasPawns() {\n        return this.white.hasPawns() || this.black.hasPawns();\n    }\n    hasNonPawns() {\n        return this.white.hasNonPawns() || this.black.hasNonPawns();\n    }\n}\nclass RemainingChecks {\n    constructor(white, black) {\n        this.white = white;\n        this.black = black;\n    }\n    static default() {\n        return new RemainingChecks(3, 3);\n    }\n    clone() {\n        return new RemainingChecks(this.white, this.black);\n    }\n    equals(other) {\n        return this.white === other.white && this.black === other.black;\n    }\n}\nconst defaultSetup = () => ({\n    board: _board_js__WEBPACK_IMPORTED_MODULE_1__.Board[\"default\"](),\n    pockets: undefined,\n    turn: 'white',\n    unmovedRooks: _squareSet_js__WEBPACK_IMPORTED_MODULE_2__.SquareSet.corners(),\n    epSquare: undefined,\n    remainingChecks: undefined,\n    halfmoves: 0,\n    fullmoves: 1,\n});\nconst setupClone = (setup) => {\n    var _a, _b;\n    return ({\n        board: setup.board.clone(),\n        pockets: (_a = setup.pockets) === null || _a === void 0 ? void 0 : _a.clone(),\n        turn: setup.turn,\n        unmovedRooks: setup.unmovedRooks,\n        epSquare: setup.epSquare,\n        remainingChecks: (_b = setup.remainingChecks) === null || _b === void 0 ? void 0 : _b.clone(),\n        halfmoves: setup.halfmoves,\n        fullmoves: setup.fullmoves,\n    });\n};\nconst setupEquals = (left, right) => {\n    var _a, _b;\n    return (0,_board_js__WEBPACK_IMPORTED_MODULE_1__.boardEquals)(left.board, right.board) &&\n        ((right.pockets && ((_a = left.pockets) === null || _a === void 0 ? void 0 : _a.equals(right.pockets))) || (!left.pockets && !right.pockets)) &&\n        left.turn === right.turn &&\n        left.unmovedRooks.equals(right.unmovedRooks) &&\n        left.epSquare === right.epSquare &&\n        ((right.remainingChecks && ((_b = left.remainingChecks) === null || _b === void 0 ? void 0 : _b.equals(right.remainingChecks))) ||\n            (!left.remainingChecks && !right.remainingChecks)) &&\n        left.halfmoves === right.halfmoves &&\n        left.fullmoves === right.fullmoves;\n};\n//# sourceMappingURL=setup.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/setup.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SquareSet\": () => (/* binding */ SquareSet)\n/* harmony export */ });\nconst popcnt32 = (n) => {\n    n = n - ((n >>> 1) & 1431655765);\n    n = (n & 858993459) + ((n >>> 2) & 858993459);\n    return Math.imul((n + (n >>> 4)) & 252645135, 16843009) >> 24;\n};\nconst bswap32 = (n) => {\n    n = ((n >>> 8) & 16711935) | ((n & 16711935) << 8);\n    return ((n >>> 16) & 0xffff) | ((n & 0xffff) << 16);\n};\nconst rbit32 = (n) => {\n    n = ((n >>> 1) & 1431655765) | ((n & 1431655765) << 1);\n    n = ((n >>> 2) & 858993459) | ((n & 858993459) << 2);\n    n = ((n >>> 4) & 252645135) | ((n & 252645135) << 4);\n    return bswap32(n);\n};\n/**\n * An immutable set of squares, implemented as a bitboard.\n */\nclass SquareSet {\n    constructor(lo, hi) {\n        this.lo = lo | 0;\n        this.hi = hi | 0;\n    }\n    static fromSquare(square) {\n        return square >= 32 ? new SquareSet(0, 1 << (square - 32)) : new SquareSet(1 << square, 0);\n    }\n    static fromRank(rank) {\n        return new SquareSet(0xff, 0).shl64(8 * rank);\n    }\n    static fromFile(file) {\n        return new SquareSet(16843009 << file, 16843009 << file);\n    }\n    static empty() {\n        return new SquareSet(0, 0);\n    }\n    static full() {\n        return new SquareSet(4294967295, 4294967295);\n    }\n    static corners() {\n        return new SquareSet(0x81, 2164260864);\n    }\n    static center() {\n        return new SquareSet(402653184, 0x18);\n    }\n    static backranks() {\n        return new SquareSet(0xff, 4278190080);\n    }\n    static backrank(color) {\n        return color === 'white' ? new SquareSet(0xff, 0) : new SquareSet(0, 4278190080);\n    }\n    static lightSquares() {\n        return new SquareSet(1437226410, 1437226410);\n    }\n    static darkSquares() {\n        return new SquareSet(2857740885, 2857740885);\n    }\n    complement() {\n        return new SquareSet(~this.lo, ~this.hi);\n    }\n    xor(other) {\n        return new SquareSet(this.lo ^ other.lo, this.hi ^ other.hi);\n    }\n    union(other) {\n        return new SquareSet(this.lo | other.lo, this.hi | other.hi);\n    }\n    intersect(other) {\n        return new SquareSet(this.lo & other.lo, this.hi & other.hi);\n    }\n    diff(other) {\n        return new SquareSet(this.lo & ~other.lo, this.hi & ~other.hi);\n    }\n    intersects(other) {\n        return this.intersect(other).nonEmpty();\n    }\n    isDisjoint(other) {\n        return this.intersect(other).isEmpty();\n    }\n    supersetOf(other) {\n        return other.diff(this).isEmpty();\n    }\n    subsetOf(other) {\n        return this.diff(other).isEmpty();\n    }\n    shr64(shift) {\n        if (shift >= 64)\n            return SquareSet.empty();\n        if (shift >= 32)\n            return new SquareSet(this.hi >>> (shift - 32), 0);\n        if (shift > 0)\n            return new SquareSet((this.lo >>> shift) ^ (this.hi << (32 - shift)), this.hi >>> shift);\n        return this;\n    }\n    shl64(shift) {\n        if (shift >= 64)\n            return SquareSet.empty();\n        if (shift >= 32)\n            return new SquareSet(0, this.lo << (shift - 32));\n        if (shift > 0)\n            return new SquareSet(this.lo << shift, (this.hi << shift) ^ (this.lo >>> (32 - shift)));\n        return this;\n    }\n    bswap64() {\n        return new SquareSet(bswap32(this.hi), bswap32(this.lo));\n    }\n    rbit64() {\n        return new SquareSet(rbit32(this.hi), rbit32(this.lo));\n    }\n    minus64(other) {\n        const lo = this.lo - other.lo;\n        const c = ((lo & other.lo & 1) + (other.lo >>> 1) + (lo >>> 1)) >>> 31;\n        return new SquareSet(lo, this.hi - (other.hi + c));\n    }\n    equals(other) {\n        return this.lo === other.lo && this.hi === other.hi;\n    }\n    size() {\n        return popcnt32(this.lo) + popcnt32(this.hi);\n    }\n    isEmpty() {\n        return this.lo === 0 && this.hi === 0;\n    }\n    nonEmpty() {\n        return this.lo !== 0 || this.hi !== 0;\n    }\n    has(square) {\n        return (square >= 32 ? this.hi & (1 << (square - 32)) : this.lo & (1 << square)) !== 0;\n    }\n    set(square, on) {\n        return on ? this.with(square) : this.without(square);\n    }\n    with(square) {\n        return square >= 32\n            ? new SquareSet(this.lo, this.hi | (1 << (square - 32)))\n            : new SquareSet(this.lo | (1 << square), this.hi);\n    }\n    without(square) {\n        return square >= 32\n            ? new SquareSet(this.lo, this.hi & ~(1 << (square - 32)))\n            : new SquareSet(this.lo & ~(1 << square), this.hi);\n    }\n    toggle(square) {\n        return square >= 32\n            ? new SquareSet(this.lo, this.hi ^ (1 << (square - 32)))\n            : new SquareSet(this.lo ^ (1 << square), this.hi);\n    }\n    last() {\n        if (this.hi !== 0)\n            return 63 - Math.clz32(this.hi);\n        if (this.lo !== 0)\n            return 31 - Math.clz32(this.lo);\n        return;\n    }\n    first() {\n        if (this.lo !== 0)\n            return 31 - Math.clz32(this.lo & -this.lo);\n        if (this.hi !== 0)\n            return 63 - Math.clz32(this.hi & -this.hi);\n        return;\n    }\n    withoutFirst() {\n        if (this.lo !== 0)\n            return new SquareSet(this.lo & (this.lo - 1), this.hi);\n        return new SquareSet(0, this.hi & (this.hi - 1));\n    }\n    moreThanOne() {\n        return (this.hi !== 0 && this.lo !== 0) || (this.lo & (this.lo - 1)) !== 0 || (this.hi & (this.hi - 1)) !== 0;\n    }\n    singleSquare() {\n        return this.moreThanOne() ? undefined : this.last();\n    }\n    *[Symbol.iterator]() {\n        let lo = this.lo;\n        let hi = this.hi;\n        while (lo !== 0) {\n            const idx = 31 - Math.clz32(lo & -lo);\n            lo ^= 1 << idx;\n            yield idx;\n        }\n        while (hi !== 0) {\n            const idx = 31 - Math.clz32(hi & -hi);\n            hi ^= 1 << idx;\n            yield 32 + idx;\n        }\n    }\n    *reversed() {\n        let lo = this.lo;\n        let hi = this.hi;\n        while (hi !== 0) {\n            const idx = 31 - Math.clz32(hi);\n            hi ^= 1 << idx;\n            yield 32 + idx;\n        }\n        while (lo !== 0) {\n            const idx = 31 - Math.clz32(lo);\n            lo ^= 1 << idx;\n            yield idx;\n        }\n    }\n}\n//# sourceMappingURL=squareSet.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CASTLING_SIDES\": () => (/* binding */ CASTLING_SIDES),\n/* harmony export */   \"COLORS\": () => (/* binding */ COLORS),\n/* harmony export */   \"FILE_NAMES\": () => (/* binding */ FILE_NAMES),\n/* harmony export */   \"RANK_NAMES\": () => (/* binding */ RANK_NAMES),\n/* harmony export */   \"ROLES\": () => (/* binding */ ROLES),\n/* harmony export */   \"RULES\": () => (/* binding */ RULES),\n/* harmony export */   \"isDrop\": () => (/* binding */ isDrop),\n/* harmony export */   \"isNormal\": () => (/* binding */ isNormal)\n/* harmony export */ });\nconst FILE_NAMES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\nconst RANK_NAMES = ['1', '2', '3', '4', '5', '6', '7', '8'];\nconst COLORS = ['white', 'black'];\nconst ROLES = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'];\nconst CASTLING_SIDES = ['a', 'h'];\nconst isDrop = (v) => 'role' in v;\nconst isNormal = (v) => 'from' in v;\nconst RULES = [\n    'chess',\n    'antichess',\n    'kingofthehill',\n    '3check',\n    'atomic',\n    'horde',\n    'racingkings',\n    'crazyhouse',\n];\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"charToRole\": () => (/* binding */ charToRole),\n/* harmony export */   \"defined\": () => (/* binding */ defined),\n/* harmony export */   \"kingCastlesTo\": () => (/* binding */ kingCastlesTo),\n/* harmony export */   \"makeSquare\": () => (/* binding */ makeSquare),\n/* harmony export */   \"makeUci\": () => (/* binding */ makeUci),\n/* harmony export */   \"moveEquals\": () => (/* binding */ moveEquals),\n/* harmony export */   \"opposite\": () => (/* binding */ opposite),\n/* harmony export */   \"parseSquare\": () => (/* binding */ parseSquare),\n/* harmony export */   \"parseUci\": () => (/* binding */ parseUci),\n/* harmony export */   \"roleToChar\": () => (/* binding */ roleToChar),\n/* harmony export */   \"rookCastlesTo\": () => (/* binding */ rookCastlesTo),\n/* harmony export */   \"squareFile\": () => (/* binding */ squareFile),\n/* harmony export */   \"squareRank\": () => (/* binding */ squareRank)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js\");\n\nconst defined = (v) => v !== undefined;\nconst opposite = (color) => (color === 'white' ? 'black' : 'white');\nconst squareRank = (square) => square >> 3;\nconst squareFile = (square) => square & 0x7;\nconst roleToChar = (role) => {\n    switch (role) {\n        case 'pawn':\n            return 'p';\n        case 'knight':\n            return 'n';\n        case 'bishop':\n            return 'b';\n        case 'rook':\n            return 'r';\n        case 'queen':\n            return 'q';\n        case 'king':\n            return 'k';\n    }\n};\nfunction charToRole(ch) {\n    switch (ch.toLowerCase()) {\n        case 'p':\n            return 'pawn';\n        case 'n':\n            return 'knight';\n        case 'b':\n            return 'bishop';\n        case 'r':\n            return 'rook';\n        case 'q':\n            return 'queen';\n        case 'k':\n            return 'king';\n        default:\n            return;\n    }\n}\nfunction parseSquare(str) {\n    if (str.length !== 2)\n        return;\n    const file = str.charCodeAt(0) - 'a'.charCodeAt(0);\n    const rank = str.charCodeAt(1) - '1'.charCodeAt(0);\n    if (file < 0 || file >= 8 || rank < 0 || rank >= 8)\n        return;\n    return file + 8 * rank;\n}\nconst makeSquare = (square) => (_types_js__WEBPACK_IMPORTED_MODULE_0__.FILE_NAMES[squareFile(square)] + _types_js__WEBPACK_IMPORTED_MODULE_0__.RANK_NAMES[squareRank(square)]);\nconst parseUci = (str) => {\n    if (str[1] === '@' && str.length === 4) {\n        const role = charToRole(str[0]);\n        const to = parseSquare(str.slice(2));\n        if (role && defined(to))\n            return { role, to };\n    }\n    else if (str.length === 4 || str.length === 5) {\n        const from = parseSquare(str.slice(0, 2));\n        const to = parseSquare(str.slice(2, 4));\n        let promotion;\n        if (str.length === 5) {\n            promotion = charToRole(str[4]);\n            if (!promotion)\n                return;\n        }\n        if (defined(from) && defined(to))\n            return { from, to, promotion };\n    }\n    return;\n};\nconst moveEquals = (left, right) => {\n    if (left.to !== right.to)\n        return false;\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isDrop)(left))\n        return (0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isDrop)(right) && left.role === right.role;\n    else\n        return (0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isNormal)(right) && left.from === right.from && left.promotion === right.promotion;\n};\n/**\n * Converts a move to UCI notation, like `g1f3` for a normal move,\n * `a7a8q` for promotion to a queen, and `Q@f7` for a Crazyhouse drop.\n */\nconst makeUci = (move) => (0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isDrop)(move)\n    ? `${roleToChar(move.role).toUpperCase()}@${makeSquare(move.to)}`\n    : makeSquare(move.from) + makeSquare(move.to) + (move.promotion ? roleToChar(move.promotion) : '');\nconst kingCastlesTo = (color, side) => color === 'white' ? (side === 'a' ? 2 : 6) : side === 'a' ? 58 : 62;\nconst rookCastlesTo = (color, side) => color === 'white' ? (side === 'a' ? 3 : 5) : side === 'a' ? 59 : 61;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js?");

/***/ }),

/***/ "./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/variant.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/variant.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Antichess\": () => (/* binding */ Antichess),\n/* harmony export */   \"Atomic\": () => (/* binding */ Atomic),\n/* harmony export */   \"Castles\": () => (/* reexport safe */ _chess_js__WEBPACK_IMPORTED_MODULE_0__.Castles),\n/* harmony export */   \"Chess\": () => (/* reexport safe */ _chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess),\n/* harmony export */   \"Crazyhouse\": () => (/* binding */ Crazyhouse),\n/* harmony export */   \"Horde\": () => (/* binding */ Horde),\n/* harmony export */   \"IllegalSetup\": () => (/* reexport safe */ _chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup),\n/* harmony export */   \"KingOfTheHill\": () => (/* binding */ KingOfTheHill),\n/* harmony export */   \"Position\": () => (/* reexport safe */ _chess_js__WEBPACK_IMPORTED_MODULE_0__.Position),\n/* harmony export */   \"PositionError\": () => (/* reexport safe */ _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError),\n/* harmony export */   \"RacingKings\": () => (/* binding */ RacingKings),\n/* harmony export */   \"ThreeCheck\": () => (/* binding */ ThreeCheck),\n/* harmony export */   \"castlingSide\": () => (/* reexport safe */ _chess_js__WEBPACK_IMPORTED_MODULE_0__.castlingSide),\n/* harmony export */   \"defaultPosition\": () => (/* binding */ defaultPosition),\n/* harmony export */   \"equalsIgnoreMoves\": () => (/* reexport safe */ _chess_js__WEBPACK_IMPORTED_MODULE_0__.equalsIgnoreMoves),\n/* harmony export */   \"isStandardMaterial\": () => (/* binding */ isStandardMaterial),\n/* harmony export */   \"normalizeMove\": () => (/* reexport safe */ _chess_js__WEBPACK_IMPORTED_MODULE_0__.normalizeMove),\n/* harmony export */   \"setupPosition\": () => (/* binding */ setupPosition)\n/* harmony export */ });\n/* harmony import */ var _badrap_result__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @badrap/result */ \"./node_modules/.pnpm/@badrap+result@0.2.13/node_modules/@badrap/result/dist/index.modern.mjs\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/types.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/util.js\");\n/* harmony import */ var _attacks_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./attacks.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/attacks.js\");\n/* harmony import */ var _squareSet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./squareSet.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/squareSet.js\");\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./board.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/board.js\");\n/* harmony import */ var _setup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setup.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/setup.js\");\n/* harmony import */ var _chess_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chess.js */ \"./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/chess.js\");\n\n\n\n\n\n\n\n\n\nclass Crazyhouse extends _chess_js__WEBPACK_IMPORTED_MODULE_0__.Position {\n    constructor() {\n        super('crazyhouse');\n    }\n    reset() {\n        super.reset();\n        this.pockets = _setup_js__WEBPACK_IMPORTED_MODULE_1__.Material.empty();\n    }\n    setupUnchecked(setup) {\n        super.setupUnchecked(setup);\n        this.board.promoted = setup.board.promoted\n            .intersect(setup.board.occupied)\n            .diff(setup.board.king)\n            .diff(setup.board.pawn);\n        this.pockets = setup.pockets ? setup.pockets.clone() : _setup_js__WEBPACK_IMPORTED_MODULE_1__.Material.empty();\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup, opts) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate(opts).map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n    validate(opts) {\n        return super.validate(opts).chain(_ => {\n            var _a, _b;\n            if ((_a = this.pockets) === null || _a === void 0 ? void 0 : _a.count('king')) {\n                return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Kings));\n            }\n            if ((((_b = this.pockets) === null || _b === void 0 ? void 0 : _b.size()) || 0) + this.board.occupied.size() > 64) {\n                return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Variant));\n            }\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(undefined);\n        });\n    }\n    hasInsufficientMaterial(color) {\n        // No material can leave the game, but we can easily check this for\n        // custom positions.\n        if (!this.pockets)\n            return super.hasInsufficientMaterial(color);\n        return (this.board.occupied.size() + this.pockets.size() <= 3 &&\n            this.board.pawn.isEmpty() &&\n            this.board.promoted.isEmpty() &&\n            this.board.rooksAndQueens().isEmpty() &&\n            this.pockets.count('pawn') <= 0 &&\n            this.pockets.count('rook') <= 0 &&\n            this.pockets.count('queen') <= 0);\n    }\n    dropDests(ctx) {\n        var _a, _b;\n        const mask = this.board.occupied\n            .complement()\n            .intersect(((_a = this.pockets) === null || _a === void 0 ? void 0 : _a[this.turn].hasNonPawns())\n            ? _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.full()\n            : ((_b = this.pockets) === null || _b === void 0 ? void 0 : _b[this.turn].hasPawns())\n                ? _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.backranks().complement()\n                : _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty());\n        ctx = ctx || this.ctx();\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(ctx.king) && ctx.checkers.nonEmpty()) {\n            const checker = ctx.checkers.singleSquare();\n            if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(checker))\n                return _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n            return mask.intersect((0,_attacks_js__WEBPACK_IMPORTED_MODULE_5__.between)(checker, ctx.king));\n        }\n        else\n            return mask;\n    }\n}\nclass Atomic extends _chess_js__WEBPACK_IMPORTED_MODULE_0__.Position {\n    constructor() {\n        super('atomic');\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup, opts) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate(opts).map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n    validate(opts) {\n        // Like chess, but allow our king to be missing.\n        if (this.board.occupied.isEmpty())\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Empty));\n        if (this.board.king.size() > 2)\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Kings));\n        const otherKing = this.board.kingOf((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(this.turn));\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(otherKing))\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Kings));\n        if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.OppositeCheck));\n        }\n        if (_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.backranks().intersects(this.board.pawn)) {\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.PawnsOnBackrank));\n        }\n        return (opts === null || opts === void 0 ? void 0 : opts.ignoreImpossibleCheck) ? _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(undefined) : this.validateCheckers();\n    }\n    validateCheckers() {\n        // Other king moving away can cause many checks to be given at the\n        // same time. Not checking details or even that the king is close enough.\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(this.epSquare) ? _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(undefined) : super.validateCheckers();\n    }\n    kingAttackers(square, attacker, occupied) {\n        const attackerKings = this.board.pieces(attacker, 'king');\n        if (attackerKings.isEmpty() || (0,_attacks_js__WEBPACK_IMPORTED_MODULE_5__.kingAttacks)(square).intersects(attackerKings)) {\n            return _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n        }\n        return super.kingAttackers(square, attacker, occupied);\n    }\n    playCaptureAt(square, captured) {\n        super.playCaptureAt(square, captured);\n        this.board.take(square);\n        for (const explode of (0,_attacks_js__WEBPACK_IMPORTED_MODULE_5__.kingAttacks)(square).intersect(this.board.occupied).diff(this.board.pawn)) {\n            const piece = this.board.take(explode);\n            if ((piece === null || piece === void 0 ? void 0 : piece.role) === 'rook')\n                this.castles.discardRook(explode);\n            if ((piece === null || piece === void 0 ? void 0 : piece.role) === 'king')\n                this.castles.discardColor(piece.color);\n        }\n    }\n    hasInsufficientMaterial(color) {\n        // Remaining material does not matter if the enemy king is already\n        // exploded.\n        if (this.board.pieces((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color), 'king').isEmpty())\n            return false;\n        // Bare king cannot mate.\n        if (this.board[color].diff(this.board.king).isEmpty())\n            return true;\n        // As long as the enemy king is not alone, there is always a chance their\n        // own pieces explode next to it.\n        if (this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color)].diff(this.board.king).nonEmpty()) {\n            // Unless there are only bishops that cannot explode each other.\n            if (this.board.occupied.equals(this.board.bishop.union(this.board.king))) {\n                if (!this.board.bishop.intersect(this.board.white).intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.darkSquares())) {\n                    return !this.board.bishop.intersect(this.board.black).intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.lightSquares());\n                }\n                if (!this.board.bishop.intersect(this.board.white).intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.lightSquares())) {\n                    return !this.board.bishop.intersect(this.board.black).intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.darkSquares());\n                }\n            }\n            return false;\n        }\n        // Queen or pawn (future queen) can give mate against bare king.\n        if (this.board.queen.nonEmpty() || this.board.pawn.nonEmpty())\n            return false;\n        // Single knight, bishop or rook cannot mate against bare king.\n        if (this.board.knight.union(this.board.bishop).union(this.board.rook).size() === 1)\n            return true;\n        // If only knights, more than two are required to mate bare king.\n        if (this.board.occupied.equals(this.board.knight.union(this.board.king))) {\n            return this.board.knight.size() <= 2;\n        }\n        return false;\n    }\n    dests(square, ctx) {\n        ctx = ctx || this.ctx();\n        let dests = _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n        for (const to of (0,_chess_js__WEBPACK_IMPORTED_MODULE_0__.pseudoDests)(this, square, ctx)) {\n            const after = this.clone();\n            after.play({ from: square, to });\n            const ourKing = after.board.kingOf(this.turn);\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(ourKing) &&\n                (!(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(after.board.kingOf(after.turn)) ||\n                    after.kingAttackers(ourKing, after.turn, after.board.occupied).isEmpty())) {\n                dests = dests.with(to);\n            }\n        }\n        return dests;\n    }\n    isVariantEnd() {\n        return !!this.variantOutcome();\n    }\n    variantOutcome(_ctx) {\n        for (const color of _types_js__WEBPACK_IMPORTED_MODULE_6__.COLORS) {\n            if (this.board.pieces(color, 'king').isEmpty())\n                return { winner: (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color) };\n        }\n        return;\n    }\n}\nclass Antichess extends _chess_js__WEBPACK_IMPORTED_MODULE_0__.Position {\n    constructor() {\n        super('antichess');\n    }\n    reset() {\n        super.reset();\n        this.castles = _chess_js__WEBPACK_IMPORTED_MODULE_0__.Castles.empty();\n    }\n    setupUnchecked(setup) {\n        super.setupUnchecked(setup);\n        this.castles = _chess_js__WEBPACK_IMPORTED_MODULE_0__.Castles.empty();\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup, opts) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate(opts).map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n    validate(_opts) {\n        if (this.board.occupied.isEmpty())\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Empty));\n        if (_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.backranks().intersects(this.board.pawn))\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.PawnsOnBackrank));\n        return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(undefined);\n    }\n    kingAttackers(_square, _attacker, _occupied) {\n        return _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n    }\n    ctx() {\n        const ctx = super.ctx();\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(this.epSquare) &&\n            (0,_attacks_js__WEBPACK_IMPORTED_MODULE_5__.pawnAttacks)((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(this.turn), this.epSquare).intersects(this.board.pieces(this.turn, 'pawn'))) {\n            ctx.mustCapture = true;\n            return ctx;\n        }\n        const enemy = this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(this.turn)];\n        for (const from of this.board[this.turn]) {\n            if ((0,_chess_js__WEBPACK_IMPORTED_MODULE_0__.pseudoDests)(this, from, ctx).intersects(enemy)) {\n                ctx.mustCapture = true;\n                return ctx;\n            }\n        }\n        return ctx;\n    }\n    dests(square, ctx) {\n        ctx = ctx || this.ctx();\n        const dests = (0,_chess_js__WEBPACK_IMPORTED_MODULE_0__.pseudoDests)(this, square, ctx);\n        const enemy = this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(this.turn)];\n        return dests.intersect(ctx.mustCapture\n            ? (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(this.epSquare) && this.board.getRole(square) === 'pawn'\n                ? enemy.with(this.epSquare)\n                : enemy\n            : _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.full());\n    }\n    hasInsufficientMaterial(color) {\n        if (this.board[color].isEmpty())\n            return false;\n        if (this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color)].isEmpty())\n            return true;\n        if (this.board.occupied.equals(this.board.bishop)) {\n            const weSomeOnLight = this.board[color].intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.lightSquares());\n            const weSomeOnDark = this.board[color].intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.darkSquares());\n            const theyAllOnDark = this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color)].isDisjoint(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.lightSquares());\n            const theyAllOnLight = this.board[(0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color)].isDisjoint(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.darkSquares());\n            return (weSomeOnLight && theyAllOnDark) || (weSomeOnDark && theyAllOnLight);\n        }\n        if (this.board.occupied.equals(this.board.knight) && this.board.occupied.size() === 2) {\n            return ((this.board.white.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.lightSquares()) !==\n                this.board.black.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.darkSquares())) !==\n                (this.turn === color));\n        }\n        return false;\n    }\n    isVariantEnd() {\n        return this.board[this.turn].isEmpty();\n    }\n    variantOutcome(ctx) {\n        ctx = ctx || this.ctx();\n        if (ctx.variantEnd || this.isStalemate(ctx)) {\n            return { winner: this.turn };\n        }\n        return;\n    }\n}\nclass KingOfTheHill extends _chess_js__WEBPACK_IMPORTED_MODULE_0__.Position {\n    constructor() {\n        super('kingofthehill');\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup, opts) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate(opts).map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n    hasInsufficientMaterial(_color) {\n        return false;\n    }\n    isVariantEnd() {\n        return this.board.king.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.center());\n    }\n    variantOutcome(_ctx) {\n        for (const color of _types_js__WEBPACK_IMPORTED_MODULE_6__.COLORS) {\n            if (this.board.pieces(color, 'king').intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.center()))\n                return { winner: color };\n        }\n        return;\n    }\n}\nclass ThreeCheck extends _chess_js__WEBPACK_IMPORTED_MODULE_0__.Position {\n    constructor() {\n        super('3check');\n    }\n    reset() {\n        super.reset();\n        this.remainingChecks = _setup_js__WEBPACK_IMPORTED_MODULE_1__.RemainingChecks[\"default\"]();\n    }\n    setupUnchecked(setup) {\n        var _a;\n        super.setupUnchecked(setup);\n        this.remainingChecks = ((_a = setup.remainingChecks) === null || _a === void 0 ? void 0 : _a.clone()) || _setup_js__WEBPACK_IMPORTED_MODULE_1__.RemainingChecks[\"default\"]();\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup, opts) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate(opts).map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n    hasInsufficientMaterial(color) {\n        return this.board.pieces(color, 'king').equals(this.board[color]);\n    }\n    isVariantEnd() {\n        return !!this.remainingChecks && (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0);\n    }\n    variantOutcome(_ctx) {\n        if (this.remainingChecks) {\n            for (const color of _types_js__WEBPACK_IMPORTED_MODULE_6__.COLORS) {\n                if (this.remainingChecks[color] <= 0)\n                    return { winner: color };\n            }\n        }\n        return;\n    }\n}\nconst racingKingsBoard = () => {\n    const board = _board_js__WEBPACK_IMPORTED_MODULE_7__.Board.empty();\n    board.occupied = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0xffff, 0);\n    board.promoted = _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n    board.white = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0xf0f0, 0);\n    board.black = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0x0f0f, 0);\n    board.pawn = _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n    board.knight = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0x1818, 0);\n    board.bishop = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0x2424, 0);\n    board.rook = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0x4242, 0);\n    board.queen = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0x0081, 0);\n    board.king = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0x8100, 0);\n    return board;\n};\nclass RacingKings extends _chess_js__WEBPACK_IMPORTED_MODULE_0__.Position {\n    constructor() {\n        super('racingkings');\n    }\n    reset() {\n        this.board = racingKingsBoard();\n        this.pockets = undefined;\n        this.turn = 'white';\n        this.castles = _chess_js__WEBPACK_IMPORTED_MODULE_0__.Castles.empty();\n        this.epSquare = undefined;\n        this.remainingChecks = undefined;\n        this.halfmoves = 0;\n        this.fullmoves = 1;\n    }\n    setupUnchecked(setup) {\n        super.setupUnchecked(setup);\n        this.castles = _chess_js__WEBPACK_IMPORTED_MODULE_0__.Castles.empty();\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup, opts) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate(opts).map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n    validate(opts) {\n        if (this.isCheck() || this.board.pawn.nonEmpty())\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Variant));\n        return super.validate(opts);\n    }\n    dests(square, ctx) {\n        ctx = ctx || this.ctx();\n        // Kings cannot give check.\n        if (square === ctx.king)\n            return super.dests(square, ctx);\n        // Do not allow giving check.\n        let dests = _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n        for (const to of super.dests(square, ctx)) {\n            // Valid, because there are no promotions (or even pawns).\n            const move = { from: square, to };\n            const after = this.clone();\n            after.play(move);\n            if (!after.isCheck())\n                dests = dests.with(to);\n        }\n        return dests;\n    }\n    hasInsufficientMaterial(_color) {\n        return false;\n    }\n    isVariantEnd() {\n        const goal = _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.fromRank(7);\n        const inGoal = this.board.king.intersect(goal);\n        if (inGoal.isEmpty())\n            return false;\n        if (this.turn === 'white' || inGoal.intersects(this.board.black))\n            return true;\n        // White has reached the backrank. Check if black can catch up.\n        const blackKing = this.board.kingOf('black');\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(blackKing)) {\n            const occ = this.board.occupied.without(blackKing);\n            for (const target of (0,_attacks_js__WEBPACK_IMPORTED_MODULE_5__.kingAttacks)(blackKing).intersect(goal).diff(this.board.black)) {\n                if (this.kingAttackers(target, 'white', occ).isEmpty())\n                    return false;\n            }\n        }\n        return true;\n    }\n    variantOutcome(ctx) {\n        if (ctx ? !ctx.variantEnd : !this.isVariantEnd())\n            return;\n        const goal = _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.fromRank(7);\n        const blackInGoal = this.board.pieces('black', 'king').intersects(goal);\n        const whiteInGoal = this.board.pieces('white', 'king').intersects(goal);\n        if (blackInGoal && !whiteInGoal)\n            return { winner: 'black' };\n        if (whiteInGoal && !blackInGoal)\n            return { winner: 'white' };\n        return { winner: undefined };\n    }\n}\nconst hordeBoard = () => {\n    const board = _board_js__WEBPACK_IMPORTED_MODULE_7__.Board.empty();\n    board.occupied = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(4294967295, 4294901862);\n    board.promoted = _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.empty();\n    board.white = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(4294967295, 102);\n    board.black = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0, 4294901760);\n    board.pawn = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(4294967295, 16711782);\n    board.knight = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0, 1107296256);\n    board.bishop = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0, 603979776);\n    board.rook = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0, 2164260864);\n    board.queen = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0, 134217728);\n    board.king = new _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet(0, 268435456);\n    return board;\n};\nclass Horde extends _chess_js__WEBPACK_IMPORTED_MODULE_0__.Position {\n    constructor() {\n        super('horde');\n    }\n    reset() {\n        this.board = hordeBoard();\n        this.pockets = undefined;\n        this.turn = 'white';\n        this.castles = _chess_js__WEBPACK_IMPORTED_MODULE_0__.Castles[\"default\"]();\n        this.castles.discardColor('white');\n        this.epSquare = undefined;\n        this.remainingChecks = undefined;\n        this.halfmoves = 0;\n        this.fullmoves = 1;\n    }\n    static default() {\n        const pos = new this();\n        pos.reset();\n        return pos;\n    }\n    static fromSetup(setup, opts) {\n        const pos = new this();\n        pos.setupUnchecked(setup);\n        return pos.validate(opts).map(_ => pos);\n    }\n    clone() {\n        return super.clone();\n    }\n    validate(opts) {\n        if (this.board.occupied.isEmpty())\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Empty));\n        if (this.board.king.size() !== 1)\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.Kings));\n        const otherKing = this.board.kingOf((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(this.turn));\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.defined)(otherKing) && this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty())\n            return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.OppositeCheck));\n        for (const color of _types_js__WEBPACK_IMPORTED_MODULE_6__.COLORS) {\n            const backranks = this.board.pieces(color, 'king').isEmpty()\n                ? _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.backrank((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color))\n                : _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.backranks();\n            if (this.board.pieces(color, 'pawn').intersects(backranks)) {\n                return _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.err(new _chess_js__WEBPACK_IMPORTED_MODULE_0__.PositionError(_chess_js__WEBPACK_IMPORTED_MODULE_0__.IllegalSetup.PawnsOnBackrank));\n            }\n        }\n        return (opts === null || opts === void 0 ? void 0 : opts.ignoreImpossibleCheck) ? _badrap_result__WEBPACK_IMPORTED_MODULE_2__.Result.ok(undefined) : this.validateCheckers();\n    }\n    hasInsufficientMaterial(color) {\n        // The side with the king can always win by capturing the horde.\n        if (this.board.pieces(color, 'king').nonEmpty())\n            return false;\n        const oppositeSquareColor = (squareColor) => (squareColor === 'light' ? 'dark' : 'light');\n        const coloredSquares = (squareColor) => squareColor === 'light' ? _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.lightSquares() : _squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.darkSquares();\n        const hasBishopPair = (side) => {\n            const bishops = this.board.pieces(side, 'bishop');\n            return bishops.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.darkSquares()) && bishops.intersects(_squareSet_js__WEBPACK_IMPORTED_MODULE_3__.SquareSet.lightSquares());\n        };\n        // By this point: color is the horde.\n        // Based on\n        // https://github.com/stevepapazis/horde-insufficient-material-tests.\n        const horde = _setup_js__WEBPACK_IMPORTED_MODULE_1__.MaterialSide.fromBoard(this.board, color);\n        const hordeBishops = (squareColor) => coloredSquares(squareColor).intersect(this.board.pieces(color, 'bishop')).size();\n        const hordeBishopColor = hordeBishops('light') >= 1 ? 'light' : 'dark';\n        const hordeNum = horde.pawn +\n            horde.knight +\n            horde.rook +\n            horde.queen +\n            Math.min(hordeBishops('dark'), 2) +\n            Math.min(hordeBishops('light'), 2);\n        const pieces = _setup_js__WEBPACK_IMPORTED_MODULE_1__.MaterialSide.fromBoard(this.board, (0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color));\n        const piecesBishops = (squareColor) => coloredSquares(squareColor)\n            .intersect(this.board.pieces((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color), 'bishop'))\n            .size();\n        const piecesNum = pieces.size();\n        const piecesOfRoleNot = (piece) => piecesNum - piece;\n        if (hordeNum === 0)\n            return true;\n        if (hordeNum >= 4) {\n            // Four or more pieces can always deliver mate.\n            return false;\n        }\n        if ((horde.pawn >= 1 || horde.queen >= 1) && hordeNum >= 2) {\n            // Pawns/queens are never insufficient material when paired with any other\n            // piece (a pawn promotes to a queen and delivers mate).\n            return false;\n        }\n        if (horde.rook >= 1 && hordeNum >= 2) {\n            // A rook is insufficient material only when it is paired with a bishop\n            // against a lone king. The horde can mate in any other case.\n            // A rook on A1 and a bishop on C3 mate a king on B1 when there is a\n            // friendly pawn/opposite-color-bishop/rook/queen on C2.\n            // A rook on B8 and a bishop C3 mate a king on A1 when there is a friendly\n            // knight on A2.\n            if (!(hordeNum === 2 &&\n                horde.rook === 1 &&\n                horde.bishop === 1 &&\n                piecesOfRoleNot(piecesBishops(hordeBishopColor)) === 1))\n                return false;\n        }\n        if (hordeNum === 1) {\n            if (piecesNum === 1) {\n                // A lone piece cannot mate a lone king.\n                return true;\n            }\n            else if (horde.queen === 1) {\n                // The horde has a lone queen.\n                // A lone queen mates a king on A1 bounded by:\n                //  -- a pawn/rook on A2\n                //  -- two same color bishops on A2, B1\n                // We ignore every other mating case, since it can be reduced to\n                // the two previous cases (e.g. a black pawn on A2 and a black\n                // bishop on B1).\n                return !(pieces.pawn >= 1 || pieces.rook >= 1 || piecesBishops('light') >= 2 || piecesBishops('dark') >= 2);\n            }\n            else if (horde.pawn === 1) {\n                // Promote the pawn to a queen or a knight and check whether white\n                // can mate.\n                const pawnSquare = this.board.pieces(color, 'pawn').last();\n                const promoteToQueen = this.clone();\n                promoteToQueen.board.set(pawnSquare, { color, role: 'queen' });\n                const promoteToKnight = this.clone();\n                promoteToKnight.board.set(pawnSquare, { color, role: 'knight' });\n                return promoteToQueen.hasInsufficientMaterial(color) && promoteToKnight.hasInsufficientMaterial(color);\n            }\n            else if (horde.rook === 1) {\n                // A lone rook mates a king on A8 bounded by a pawn/rook on A7 and a\n                // pawn/knight on B7. We ignore every other case, since it can be\n                // reduced to the two previous cases.\n                // (e.g. three pawns on A7, B7, C7)\n                return !(pieces.pawn >= 2 ||\n                    (pieces.rook >= 1 && pieces.pawn >= 1) ||\n                    (pieces.rook >= 1 && pieces.knight >= 1) ||\n                    (pieces.pawn >= 1 && pieces.knight >= 1));\n            }\n            else if (horde.bishop === 1) {\n                // The horde has a lone bishop.\n                return !(\n                // The king can be mated on A1 if there is a pawn/opposite-color-bishop\n                // on A2 and an opposite-color-bishop on B1.\n                // If black has two or more pawns, white gets the benefit of the doubt;\n                // there is an outside chance that white promotes its pawns to\n                // opposite-color-bishops and selfmates theirself.\n                // Every other case that the king is mated by the bishop requires that\n                // black has two pawns or two opposite-color-bishop or a pawn and an\n                // opposite-color-bishop.\n                // For example a king on A3 can be mated if there is\n                // a pawn/opposite-color-bishop on A4, a pawn/opposite-color-bishop on\n                // B3, a pawn/bishop/rook/queen on A2 and any other piece on B2.\n                (piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 2 ||\n                    (piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1 && pieces.pawn >= 1) ||\n                    pieces.pawn >= 2));\n            }\n            else if (horde.knight === 1) {\n                // The horde has a lone knight.\n                return !(\n                // The king on A1 can be smother mated by a knight on C2 if there is\n                // a pawn/knight/bishop on B2, a knight/rook on B1 and any other piece\n                // on A2.\n                // Moreover, when black has four or more pieces and two of them are\n                // pawns, black can promote their pawns and selfmate theirself.\n                (piecesNum >= 4 &&\n                    (pieces.knight >= 2 ||\n                        pieces.pawn >= 2 ||\n                        (pieces.rook >= 1 && pieces.knight >= 1) ||\n                        (pieces.rook >= 1 && pieces.bishop >= 1) ||\n                        (pieces.knight >= 1 && pieces.bishop >= 1) ||\n                        (pieces.rook >= 1 && pieces.pawn >= 1) ||\n                        (pieces.knight >= 1 && pieces.pawn >= 1) ||\n                        (pieces.bishop >= 1 && pieces.pawn >= 1) ||\n                        (hasBishopPair((0,_util_js__WEBPACK_IMPORTED_MODULE_4__.opposite)(color)) && pieces.pawn >= 1)) &&\n                    (piecesBishops('dark') < 2 || piecesOfRoleNot(piecesBishops('dark')) >= 3) &&\n                    (piecesBishops('light') < 2 || piecesOfRoleNot(piecesBishops('light')) >= 3)));\n            }\n            // By this point, we only need to deal with white's minor pieces.\n        }\n        else if (hordeNum === 2) {\n            if (piecesNum === 1) {\n                // Two minor pieces cannot mate a lone king.\n                return true;\n            }\n            else if (horde.knight === 2) {\n                // A king on A1 is mated by two knights, if it is obstructed by a\n                // pawn/bishop/knight on B2. On the other hand, if black only has\n                // major pieces it is a draw.\n                return pieces.pawn + pieces.bishop + pieces.knight < 1;\n            }\n            else if (hasBishopPair(color)) {\n                return !(\n                // A king on A1 obstructed by a pawn/bishop on A2 is mated\n                // by the bishop pair.\n                (pieces.pawn >= 1 ||\n                    pieces.bishop >= 1 ||\n                    // A pawn/bishop/knight on B4, a pawn/bishop/rook/queen on\n                    // A4 and the king on A3 enable Boden's mate by the bishop\n                    // pair. In every other case white cannot win.\n                    (pieces.knight >= 1 && pieces.rook + pieces.queen >= 1)));\n            }\n            else if (horde.bishop >= 1 && horde.knight >= 1) {\n                // The horde has a bishop and a knight.\n                return !(\n                // A king on A1 obstructed by a pawn/opposite-color-bishop on\n                // A2 is mated by a knight on D2 and a bishop on C3.\n                (pieces.pawn >= 1 ||\n                    piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1 ||\n                    // A king on A1 bounded by two friendly pieces on A2 and B1 is\n                    // mated when the knight moves from D4 to C2 so that both the\n                    // knight and the bishop deliver check.\n                    piecesOfRoleNot(piecesBishops(hordeBishopColor)) >= 3));\n            }\n            else {\n                // The horde has two or more bishops on the same color.\n                // White can only win if black has enough material to obstruct\n                // the squares of the opposite color around the king.\n                return !(\n                // A king on A1 obstructed by a pawn/opposite-bishop/knight\n                // on A2 and a opposite-bishop/knight on B1 is mated by two\n                // bishops on B2 and C3. This position is theoretically\n                // achievable even when black has two pawns or when they\n                // have a pawn and an opposite color bishop.\n                ((pieces.pawn >= 1 && piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1) ||\n                    (pieces.pawn >= 1 && pieces.knight >= 1) ||\n                    (piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 1 && pieces.knight >= 1) ||\n                    piecesBishops(oppositeSquareColor(hordeBishopColor)) >= 2 ||\n                    pieces.knight >= 2 ||\n                    pieces.pawn >= 2)\n                // In every other case, white can only draw.\n                );\n            }\n        }\n        else if (hordeNum === 3) {\n            // A king in the corner is mated by two knights and a bishop or three\n            // knights or the bishop pair and a knight/bishop.\n            if ((horde.knight === 2 && horde.bishop === 1) || horde.knight === 3 || hasBishopPair(color)) {\n                return false;\n            }\n            else {\n                // White has two same color bishops and a knight.\n                // A king on A1 is mated by a bishop on B2, a bishop on C1 and a\n                // knight on C3, as long as there is another black piece to waste\n                // a tempo.\n                return piecesNum === 1;\n            }\n        }\n        return true;\n    }\n    isVariantEnd() {\n        return this.board.white.isEmpty() || this.board.black.isEmpty();\n    }\n    variantOutcome(_ctx) {\n        if (this.board.white.isEmpty())\n            return { winner: 'black' };\n        if (this.board.black.isEmpty())\n            return { winner: 'white' };\n        return;\n    }\n}\nconst defaultPosition = (rules) => {\n    switch (rules) {\n        case 'chess':\n            return _chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess[\"default\"]();\n        case 'antichess':\n            return Antichess.default();\n        case 'atomic':\n            return Atomic.default();\n        case 'horde':\n            return Horde.default();\n        case 'racingkings':\n            return RacingKings.default();\n        case 'kingofthehill':\n            return KingOfTheHill.default();\n        case '3check':\n            return ThreeCheck.default();\n        case 'crazyhouse':\n            return Crazyhouse.default();\n    }\n};\nconst setupPosition = (rules, setup, opts) => {\n    switch (rules) {\n        case 'chess':\n            return _chess_js__WEBPACK_IMPORTED_MODULE_0__.Chess.fromSetup(setup, opts);\n        case 'antichess':\n            return Antichess.fromSetup(setup, opts);\n        case 'atomic':\n            return Atomic.fromSetup(setup, opts);\n        case 'horde':\n            return Horde.fromSetup(setup, opts);\n        case 'racingkings':\n            return RacingKings.fromSetup(setup, opts);\n        case 'kingofthehill':\n            return KingOfTheHill.fromSetup(setup, opts);\n        case '3check':\n            return ThreeCheck.fromSetup(setup, opts);\n        case 'crazyhouse':\n            return Crazyhouse.fromSetup(setup, opts);\n    }\n};\nconst isStandardMaterial = (pos) => {\n    var _a, _b, _c, _d, _e;\n    switch (pos.rules) {\n        case 'chess':\n        case 'antichess':\n        case 'atomic':\n        case 'kingofthehill':\n        case '3check':\n            return _types_js__WEBPACK_IMPORTED_MODULE_6__.COLORS.every(color => (0,_chess_js__WEBPACK_IMPORTED_MODULE_0__.isStandardMaterialSide)(pos.board, color));\n        case 'crazyhouse': {\n            const promoted = pos.board.promoted;\n            return (promoted.size() + pos.board.pawn.size() + (((_a = pos.pockets) === null || _a === void 0 ? void 0 : _a.count('pawn')) || 0) <= 16 &&\n                pos.board.knight.diff(promoted).size() + (((_b = pos.pockets) === null || _b === void 0 ? void 0 : _b.count('knight')) || 0) <= 4 &&\n                pos.board.bishop.diff(promoted).size() + (((_c = pos.pockets) === null || _c === void 0 ? void 0 : _c.count('bishop')) || 0) <= 4 &&\n                pos.board.rook.diff(promoted).size() + (((_d = pos.pockets) === null || _d === void 0 ? void 0 : _d.count('rook')) || 0) <= 4 &&\n                pos.board.queen.diff(promoted).size() + (((_e = pos.pockets) === null || _e === void 0 ? void 0 : _e.count('queen')) || 0) <= 2);\n        }\n        case 'horde':\n            return _types_js__WEBPACK_IMPORTED_MODULE_6__.COLORS.every(color => pos.board.pieces(color, 'king').nonEmpty()\n                ? (0,_chess_js__WEBPACK_IMPORTED_MODULE_0__.isStandardMaterialSide)(pos.board, color)\n                : pos.board[color].size() <= 36);\n        case 'racingkings':\n            return _types_js__WEBPACK_IMPORTED_MODULE_6__.COLORS.every(color => pos.board.pieces(color, 'knight').size() <= 2 &&\n                pos.board.pieces(color, 'bishop').size() <= 2 &&\n                pos.board.pieces(color, 'rook').size() <= 2 &&\n                pos.board.pieces(color, 'queen').size() <= 1);\n    }\n};\n//# sourceMappingURL=variant.js.map\n\n//# sourceURL=webpack://ranklab-chess/./node_modules/.pnpm/chessops@0.12.7/node_modules/chessops/variant.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;